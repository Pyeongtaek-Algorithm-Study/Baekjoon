### 13305번: 주유소

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/13305)
2. **도움 블로그** : 

**문제 조건**
- N개의 도시가 있으며, 이 도시들은 일직선 도로위에 존재
- 제일 왼쪽 도시에서 제일 오른쪽 도시로 자동차로 이동
- 인접한 두 도시 사이의 도로들은 서로 길이가 다름
- 처음 출발할 때 자동차에는 기름이 없어서 도시의 주유소에서 기름을 넣고 출발
- 기름통은 무제한으로, 얼마든지 많은 기름을 넣을 수 있음
- 도로로 이동할 때 1km마다 1리터의 기름을 사용하고 각 도시에는 주유소가 1개씩 존재하며 도시마다 주유소의 가격은 다름

**출력**  
- 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 **최소 비용의 기름값**을 출력

### 풀이
1. 가장 적은 기름값을 사용하는 방법은 도시를 이동하면서 내가 넣은 기름값보다 더 싼 주유소가 나올 때까지만 기름을 충전
2. 그 후에는 더 싼 주유소에서 기름을 충전하고, 마찬가지로 이후에 도착할 도시에서 더 싼 주유소가 나올 때까지 충전을 반복
3. 위 과정들을 계속 반복해서 최종적으로 제일 오른쪽 도시에 도착하면은 여태동안 사용했던 **기름값들의 합산**이 곧 최소 비용
4. 최소 비용의 기름값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int p1 = 0, p2 = 0;
    ll ans = 0;
    
    while(++p1 < n) {
        ll dist = 0;
        for(int i = p1; i < n; i++) {
            // i가 마지막 도시에 도착하면은 p1을 마지막 도시에 가리킴
            if(i == n - 1) p1 = n - 1;
            dist += road[i - 1];
            
            // i번쨰 도시 주요소 값이 p2 주요소 값보다 작거나 같을 때 해당 마을을 p1으로 가리킴
            if(gas_station[i] <= gas_station[p2]) {
                p1 = i;
                break;
            }
        }
        
        // 출발 도시에서 다음 도시까지만 기름 충전
        ans += (gas_station[p2] * dist);
        p2 = p1;
    }
    
    cout << ans << '\n';
}
```
- 현재 주유소 순서를 나타내는 `p2`, 현재 주유소보다 더 싼 주유소의 순서를 나타내는 `p1`, 기름값의 합산인 `ans`
- `p1`이 `n`번 도시 도착 전까지 반복
- 현재 주유소에서 다음 더 싼 주유소까지의 거리를 나타내는 `dist`
- `p1` 도시부터 시작해서 마지막 도시까지 주유소 값이 `p2`보다 더 싸거나 같은 주유소가 있을 시에 `p1`을 해당 도시의 순서값으로 저장
- `ans`에 해당 다음 주유소까지의 거리인 `dist`와 현재 주유소 위치인 `p2` 비용의 곱을 합산
- 위 과정들을 `p1`이 마지막 도시에 도착하면은 더이상 갈 수 있는 것이 없으므로 반복문을 종료
- 최종적으로 구한 `ans` 값에는 기름의 최소 비용이 저장됌으로 이를 출력
</details>

### 후기
- c++로는 두 포인터 방식으로 풀었지만 더 쉬운 방법으론 python 풀이법이 있음
- 매 도시에 갈때마다 기름값을 비교해서 더 작은 기름값으로 각 도로의 길이를 곱한 만큼의 비용 합산으로 마지막 도시까지 구함