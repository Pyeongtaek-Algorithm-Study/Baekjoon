### 1202번: 보석 도둑

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1202)
2. **도움 블로그** : 

**문제 조건**
- 보석이 N개 있으며 각 보석은 무게 M과 가격 V를 가짐
- 상덕이는 K개의 가방을 가지고 있고, 각 가방은 C만큼의 무게를 버틸 수 있으며 가방은 1개의 보석만 담을 수 있음

**출력**  
- 상덕이가 가지고 있는 가방을 통해 **훔칠 수 있는 보석 가격의 합**의 최댓값을 출력

### 풀이
1. 가방과 보석을 무게를 기준으로 오름차순 정렬
2. `idx`를 설정하여 가방에 넣을 수 있는 보석의 위치를 파악하도록 함.
3. 오름차순으로 정렬이 되었기 때문에 가방이 버틸 수 있는 무게가 점차 증가한다는 것은 보석도 **앞선 가방의 넣었던 보석들도 포함**된다는 것
4. 보석이 가방 무게보다 작다면은 보석을 우선순위 큐 _(해당 가방에 넣을 수 있는 보석들)_ 에 담아둠
5. 큐에 담겨져 있는 보석을 가치를 기준으로 내림차순 정렬
6. 가장 탑에 있는 보석을 해당 가방에 넣고 최종 최댓값에 합산
7. 위 과정을 모든 가방에 담을 때까지 반복

### 핵심 코드

<details>
<summary>코드 보기</summary>

```py
def solve():
    gem.sort()
    bag.sort()
    
    ans = idx = 0
    pq = []
    
    for i in range(k):
        while idx < n and bag[i] >= gem[idx][0]:
            heapq.heappush(pq, (-gem[idx][1], gem[idx][1]))
            idx += 1
        if pq:
            ans += heapq.heappop(pq)[1]
            
    print(ans)
```
- 가방과 보석은 무게를 기준으로, 오름차순으로 정렬
- `ans`는 최댓 무게 결과값과 `idx`는 `heapq`에 넣을 보석의 위치를 나타냄
- 가방의 무게가 낮은 것 부터 시작하여 해당 가방에 넣을 수 있는 무게 중 가장 가치가 비싼 것을 넣어야 함
- 보석을 첫번째 부터 시작하여 `n`보다 작고, 해당 가방의 버틸 수 있는 무게가 해당 보석의 무게보다 커야 함
- 해당 보석은 해당 가방에 넣을 수 있는 것들이므로 우선순위 큐에 넣어둠  
_heapq는 자동 오름차순이기에 첫번째에 **음수**를 통해서 두번째 값이 내림차순으로 되게 설정_
- 큐에 보석의 가치가 있으면 해당 보석을 가방에 넣을 수 있는 최대 가치이므로 `ans`에 더함
- 위 과정을 반복하여 모든 가방에 보석을 넣어두고 최종 값을 출력
</details>

### 후기
- 처음에 보석을 가치를 기준으로 내림차순을 하니 복잡해져버려서 무게를 기준으로 오름차순으로 해야 했었음
- c++의 경우 int형으로 하면 값이 **오버플로우** 해저벼러서 큰 타입으로 설정해야 함.  
최악의 합산으론 $300,000 * 1,000,000$ 값이므로 int형을 넘어서버림