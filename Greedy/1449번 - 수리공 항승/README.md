### 1449번: 수리공 항승

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1449)
2. **도움 블로그** : 

**문제 조건**
- 항승이는 품질이 매우 나쁜 수도 파이프 회사의 수리공
- 파이프에서 물이 새는 곳은 가장 왼쪽에서 정수만큼 떨어진 거리에 물이 샘
- 항승이는 테이프를 이용해서 물을 막으려고, 적어도 그 위치의 **좌우 0.5만큼 간격을 줘야 물이 안샌다고 생각**
- 테이프의 길이는 L로, **중간 부분을 자를 수 없지만, 겹쳐서 붙이는 것은 가능**

**출력**  
- 항승이가 물이 새는 파이프를 알았을 때 필요한 최소의 개수를 출력

### 풀이
1. 물이 새는 곳의 위치가 항상 오름차순으로 입력받지 않으므로, 물이 새는 곳을 오름차순으로 정렬
2. 테이프의 개수인 `tape` 와, 테이프로 막을 수 있는 곳을 저장할 `len`을 0으로 초기화
3. 반복문으로 물이 새는 곳을 체크
4. `i`번째 물이 새는 곳에 `len`과 비교하여 `len`이 작으면 해당 `i`번째 물이 새는 곳을 막을 수 없음을 의미
5. `len`에는 물이 새는 곳과 테이프의 길이에 -1 값을 저장
6. 새로운 테이프를 사용했으므로 `tape++`

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
sort(pipe.begin(), pipe.end());
    
int tape = 0, len = 0;

for(int i = 0; i < n; i++) {
    if(pipe[i] > len) {
        len = pipe[i] + l - 1;
        tape++;
    }
}

cout << tape << '\n';
```
- `pipe` 값들을 오름차순으로 정렬
- `tape`는 사용될 테이프의 개수, `len`은 테이프를 붙여서 물이 새는 곳을 막을 수 있는 위치까지를 나타냄. 0으로 초기화
- `pipe[i]` 값을 `len`과 비교하여, `len`이 `pipe[i]` 값보다 작다면 해당 위치에선 물이 새는 곳을 막을 수 없음을 의미
- `pipe[i]` 번째 위치에 테이프를 붙이고 해당 `l`길이만큼 더하고 -1을 한 곳까지 막을 수 있다.

> _1, 2 가 물이 새는 곳이고, l = 2라면, 최소 0.5 ~ 2.5까지에 테이프를 붙여야 한다. 이때 1에 테이프 길이인 2를 더하면 3이 나오므로, -1을 하여 정수 3을 방지_
- 새로운 테이프를 사용한 것이므로 `tape++`
- 물이 새는 곳을 모두 확인 한 후에, 최종적인 `tape`를 출력
</details>

### 후기
- 정렬 카테고리에서 선택하여 풀었지만, 문제 특성상 그리디 알고리즘에 적합하여 이동
- 한번에 문제가 풀려서 좋았다.