### 2961번: 도영이가 만든 맛있는 음식

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2961)
2. **도움 블로그** : https://ezeun.tistory.com/205

**문제 조건**
- 도영이의 앞에는 재료가 N개 있으며, 각 재료에는 신맛과 쓴맛이 존재
- 물에 여러 재료를 이용하여 요리를 하는데, 사용한 재료의 신맛은 신맛의 곱이고, 쓴맛은 쓴맛의 합임
- 도영이는 재료를 적절히 섞어서 요리의 신맛과 쓴맛의 차이를 작게 만들려고 함.
- 물만 있는건 요리라 할 수 없기에, 적어도 한 개 이상의 재료를 사용

**출력**  
- 만든 요리의 신맛과 쓴맛의 **차이가 가장 작은 값**을 출력

### 풀이
1. 1 ~ n - 1까지의 양의 정수를 비트로 치환
2. 해당 숫자의 비트에서 1인 부분을 체크해서 1이 있다면 **해당 번쨰 재료를 사용**한 것
3. 사용한 재료를 파악하여 신맛과 쓴맛을 계산해서 **최솟값**을 갱신
4. 1(0001) 부터 n - 1(1010) 까지 반복하여 최종 값 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    for(int i = 1; i < (1 << n); i++) {
        int a = 1, b = 0;
        for(int j = 0; j < n; j++) {
            if(i & (1 << j)) {
                a *= ingre[j].first;
                b += ingre[j].second;
            }
        }
        ans = min(ans, abs(a - b));
    }
    cout << ans << '\n';
}
```
- `(1 << n)` 을 통해서 $2^n$ 까지 반복
- `a`는 신맛은 곱이기에 1로, `b`는 쓴맛으로 합이기에 0으로 초기 설정
- 다음 반복문으로 몇번째 재료를 사용하는 것인지를 체크  
_첫번째 반복문은 정수를 비트로 치환, 두번쨰 반복문은 비트에서 사용한 재료를 체크_
- `i`번째 값에서 `j`를 _Bitshift_ 해서 각 칸마다 1인지 체크
- 사용한 재료를 찾았으면 해당 재료의 신맛, 쓴맛을 계단
- `a`와 `b`의 차이를 계산한 후 `ans` 값에 갱신
- 모든 경우를 살펴본 후, 최종적인 `ans` 값 출력
</details>

### 후기
- 처음에는 _Backtracking_ 으로 풀었지만, 비트마스킹으로 찾아서 다시 풀어봄.
- 해당 양의 정수를 비트로 치환해서 1인 비트 위치를 사용한 재료로 파악하는 것이 _PS_ 의 핵심이었음.