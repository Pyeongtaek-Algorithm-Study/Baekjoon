### 11725번: 트리의 부모 찾기

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/11725)

**문제 조건**
- 루트가 1인 임의의 트리 입력
- 노드의 개수를 입력받고, 노드 간의 관계를 입력

**출력**  
- 2번 노드부터 순서대로 부모 노드의 값을 출력

### 풀이
1. 메모리 제한이 256MB이므로 `vector<int> v[100001]`를 활용  
_(노드 관계를 2차원 배열로 하면 메모리 초과)_
2. 입력 받은 노드 관계는 어느 것이 부모 노드인 것인지 모르기 때문에, 무방향으로 입력 
3. 루트 노드부터 `DFS`로 하위 노드들을 파악  
**하위 노드로 내려가면 상위 노드가 부모노드가 됨.**
4. `vis[]`을 활용하여 방문 노드를 확인하고 해당 부모 노드 값을 저장

### 핵심 코드
```
for(int i = 0; i < n; i++) {
    int a, b;
    cin >> a >> b;
    v[b].push_back(a);
    v[a].push_back(b);
}

DFS(1);
```
- 입력 받은 노드 개수로 `a`, `b`를 입력 받고 `v`에 무방향으로 입력
- `DFS(1)`로 시작하여 노드 1부터 하위 노드들을 탐색

```
void DFS(int k) {
    for(int i = 0; i < v[k].size(); i++) {
        int tmp = v[k][i];
        if(!vis[tmp]) {
            vis[tmp] = k;
            DFS(tmp);
        }
    }
}
```
- 현재 노드에서 인접한 노드 개수는 최대 2개 이고, 어느 것이 부모 노드인지를 모름.
- 현재 노드인 v[k]에서 인접한 노드가 몇개 있는지 확인 `v[k].size()`
- `tmp` 에 `v[k][i]` 를 저장하여 `vis[]`에서 값이 있는지 확인  
_(값이 있을 경우 방문한 노드이며 이미 부모 노드를 찾은 경우)_
- **방문하지 않은 노드이면은 `vis[tmp]`의 부모노드가 `k` 노드**
- 다음 노드인 `tmp`로 `DFS()`를 돌며 모든 노드를 탐색하여 `vis[]`에 각 노드의 부모 노드 값을 저장
- 1번 노드를 제외한 노드들의 부모 노드 값을 출력(2번 노드부터 순서대로 출력) 
