### 3584번: 가장 가까운 공통 조상

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/3584)
2. **도움 블로그** : https://cocoon1787.tistory.com/506

**문제 조건**
- 루트가 있는 트리가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상은 다음과 같이 정의
    - 두 노드의 가장 가까운 공통 조상은, **두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은 노드**를 말함.


**출력**  
- 각 테스트 케이스 별로, 주어진 두 노드의 가장 **가까운 공통 조상**을 출력

### 풀이
1. 루트 노드가 이미 선언이 된 트리이므로 입력 받은 두 노드중 한 노드를 선택
2. 선택한 노드를 **루트 노드에 도착할 때까지** 계속 올라가며 방문 처리
3. 나머지 노드도 부모 노드를 따라 올라가는데, 이때 이미 방문 했던 노드를 발견했으면 2번 과정에서 **선택한 노드가 지나갔던 경로이므로** 공통 조상을 만난 것
4. 가장 처음 만난 공통 조상이 가장 가까운 공통 조상이므로 이때의 노드를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
int lca(int x, int y) {
    bool vis[MAX] = { false, };
    vis[x] = true;
    
    while(x != parents[x]) {
        x = parents[x];
        vis[x] = true;
    }
    while(!vis[y]) {
        y = parents[y];
    }
    
    return y;
}
```
- 두 노드인 `x`, `y`를 입력 받음
- `vis[]`을 선언하여 초기값은 모두 방문하지 않은 상태로 저장 후, 처음 `x` 노드는 방문 처리
- `x` 노드의 부모 노드를 계산 따라가다 보면 최종적인 루트 노드까지 도착하며 이때 `vis[]`의 노드들을 방문 처리
- 다음은 `y` 노드가 방문하지 않은 곳이라면 부모 노드를 따라 계속 올라감
- 이때, `y` 노드의 부모 노드를 따라 올라갈 때 방문이 된 곳을 찾으면은 이는 `x` 노드와 `y` **노드의 공통 부모**가 됨.
- 따라서, 최종적으로 찾은 가장 가까운 공통 조상인 `y` 노드 값을 반환
</details>

### 후기
- 