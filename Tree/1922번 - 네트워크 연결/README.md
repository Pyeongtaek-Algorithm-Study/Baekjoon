### 1922번: 네트워크 연결

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1922)
2. **도움 블로그** : 

**문제 조건**
- 도현이는 컴퓨터와 컴퓨터를 모두 연결하는 네트워크 구축을 하려 함.
- 허브가 없어 컴퓨터와 컴퓨터를 직접 연결하고자 함.
- 하지만, 모두 자료를 공유하기 위해선 모든 컴퓨터가 연결이 되어 있어야 함.  
_※ A컴퓨터와 B컴퓨터가 연결선이 있고, B컴퓨터와 C컴퓨터가 연결선이 있으면 A와 C가 자료 공유 가능_
- 이왕에 컴퓨터들 끼리 연결할 때 비용을 최소로 하고자 함

**출력**  
- 각 컴퓨터끼리 연결할 수 있는 선들의 비용이 주어졌을 때, **모든 컴퓨터를 연결**하는데 필요한 최소 비용을 출력

### 풀이
1. 각각의 컴퓨터를 연결하는 데 하나의 그룹으로 만들어서 서로 자료를 공유할 수 있도록 하는 과정인 _스패닝 트리_ 과정이 있음
2. 이때의 스패닝 트리를 구성하는데 **최소 스패닝 트리**를 구현하기 위해 _크루스칼 알고리즘_ 을 활용
3. 연결하는 선들의 비용을 기준으로 **오름차순**으로 정렬
4. 비용이 적은 선들부터 컴퓨터들끼리 연결을 진행
5. 연결을 진행한 후에는 **하나의 그룹**으로 묶은 후, 계속 선을 찾으면서 이미 그룹인 컴퓨터의 선일 경우 건너뜀
6. 위 과정을 통해 최종적으로 선의 개수가 **컴퓨터 개수 - 1개** 만큼 연결이 되었을 때 이때 모든 컴퓨터들 끼리 하나의 그룹으로 묶을 수 있음
7. 위 과정에서 구한 최종적인 비용의 합산이 곧 최소 비용이므로 이 비용을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    sort(networks.begin(), networks.end());
    
    int net_cnt = 0, net_weight = 0;
    for(auto &net : networks) {
        int st = net[1], end = net[2];
        if(Find(st) == Find(end)) continue;
        
        Union(st, end);
        net_weight += net[0];
        
        if(++net_cnt == n - 1) break;
    }
    
    cout << net_weight << '\n';
}
```
- 컴퓨터의 연결 선들인 `networks`를 비용을 기준으로 오름차순으로 `sort()`
- 연결 선의 개수인 `net_cnt`와 연결했을 때의 비용 합산인 `net_weight`
- `networks`에서 1번째 위치는 시작 컴퓨터, 2번째 위치는 도착 컴퓨터
- 시작 컴퓨터와 도착 컴퓨터의 `Find()`를 통해 `parents[]`를 찾아서 서로 같으면은 하나의 그룹임으로 건너뜀
- 서로 다른 그룹이면은 하나의 그룹으로 합쳐야 함으로 `Union()` 진행
- 이때의 연결 비용인 `net[0]`을 `net_weight`에 합산
- `net_cnt`를 1 증가시킨 후 연결 선이 _컴퓨터의 개수 - 1_ 과 비교해서 같으면은 모든 컴퓨터가 연결된 것이므로 반복문 종료
- 최종적으로 구한 최소비용인 `net_weight`를 출력
</details>

### 후기
- 크루스칼 알고리즘의 기본 개념을 알려주는 간단한 알고리즘 문제였다.