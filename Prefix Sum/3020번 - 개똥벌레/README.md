### 3020번: 개똥벌레

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/3020)  
도움 블로그 : https://baebalja.tistory.com/451

**문제 조건**
- 동굴의 길이가 `N`미터이고, 높이가 `H`
- 동굴의 장애물인 석순과 종유석이 있으며 가장 첫번 째는 석순, 그다음은 종유석으로 번갈아 등장
- 개똥벌레는 자신이 지나갈 구간을 정하여 임의의 높이에서 **일직선으로 지나가면서 만나는 장애물을 파괴**  
- 아래 그림에서 개똥벌레가 높이가 4인 구간을 선택하면 만나는 장애물인 8개를 파괴
![사진01](https://upload.acmicpc.net/bfcbb94f-0e15-4ff9-b2ef-43e07c7ee503/-/preview/)

**출력**  
- 개똥벌레가 파괴하는 **장애물의 최솟값과 그러한 구간의 개수**를 공백으로 구분하여 출력

### 풀이
1. `N`의 값은 항상 짝수이므로, 한 번에 2번씩 입력받는다. 이후에 석순과 종유석을 `down`과 `up`에 저장
2. `down`과 `up`에 해당 높이에 1씩 추가한다. 종유석은 높이 `h`에서 빼고, 개똥벌레가 해당 구간에 부딪힐려면 +1을 해야하므로 `h + 1 - b` 값에 추가
3. `down`은 숫자가 낮을수록 개똥벌레가 많이 부딪히므로 높은 구간에서 아래 구간으로 내려오면서 누적합을 한다.
4. `up`은 `down`과 반대이므로 낮은 구간에서 높은 구간으로 누적합을 구한다.
5. `result`는 개똥벌레가 구간에 날면서 부딪히는 장애물 개수이므로 `down`과 `up`을 합한다.
6. `result`와 최솟값인 `min_num`과 비교하여 구한다. 만일, 구한 `result`값이 기존 최솟값과 같다면 해당 최소로 부딪히는 장애물의 구간이 더 있는 것이므로 `cnt++`을 한다.
7. `min_num`과 `cnt` 사이에 공백을 줘서 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
for(int i = 0; i < n / 2; i++) {
    int a, b;
    cin >> a >> b;
    down[a]++;
    up[h + 1 - b]++;
}

void solve() {
    for(int i = h - 1; i >= 1; i--) down[i] += down[i + 1];
    int min_num = 987654321;
    int cnt = 0;
    for(int i = 1; i <= h; i++) {
        up[i] += up[i - 1];
        result[i] += up[i] + down[i];
        if(result[i] < min_num) {
            cnt = 1;
            min_num = result[i];
        }
        else if(result[i] == min_num) cnt++;
    }
    
    cout << min_num << " " << cnt;
}
```
- 입력받을 때 `n / 2` 만큼 반복하여 석순(`down`)과 종유석(`up`)의 해당 높이구간을 +1 시킨다.
- `up`의 경우 부딪히는 것이 `h + 1 - 입력값` 이다.
- `down`의 경우 높은 곳에서 낮은 곳으로 누적합을 구한다. 이는 개똥벌레가 해당 구간에서 부딪히는 석순이다.
- `up`의 경우 반대로 낮은 곳에서 높은 곳으로 누적합을 구한다. 이는 개똥벌레가 해당 구간에서 부딪히는 종유석이다.
- `result`는 `down`과 `up`의 합산으로 해당 구간에서 부딪히는 전체 장애물이다. 이때 `min_num`과 비교하여 최솟값을 구한다.
- 만약 구한 `result`의 값이 기존 `min_num`과 같다면 최솟값의 구간이 1개 더 있는 것이므로 `cnt++`를 한다. 
</details>

### 후기
- 석순과 종유석을 나눠서 저장하며 이를 하나의 구간에서 부딪히는 개수를 구하는 로직 구상이 어려웠다.  
- 개똥벌레가 지나갈 구간의 높이가 높을 수록 장애물 개수가 감소한다.  
- 이는 높은 구간에서 낮은 구간으로 누적합을 미리 구하여 알고리즘 시간을 감소시킬 수 있다.  
- (※ 최악의 경우 200000 * 500000 의 시간이 걸리므로 간단한 방법으론 시간초과 발생)