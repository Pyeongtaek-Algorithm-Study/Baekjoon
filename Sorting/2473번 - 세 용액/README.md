### 2473번: 세 용액

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2473)
2. **도움 블로그** : 

**문제 조건**
- 산성 용액과 알칼리성 용액 보유
- 각 용액에는 특성을 나타내는 정수 값을 가지고 산성 용액은 10억까지, 알칼리성 용액은 -10억을 나타냄
- 이 연구소에서는 세 가지의 용액을 혼합하고자 하며 이때의 혼합 값이 0에 가까운 특성값을 만들고자 함.

**출력**  
- 세 개의 서로 다른 용액을 혼합하여 이때의 특성값이 0에 가장 가까운 용액을 만들어내는 세 용액의 각 특성값을 출력
- 세 용액의 각 특성값을 오름차순으로 출력
- 0에 가까운 용액을 만드는 경우가 두 개 이상일 시에는 아무거나 출력

### 풀이
1. 2407번의 문제와 매우 흡사한 문제이다.
2. 입력받은 용액의 특성 값을 오름차순으로 정렬
3. 정렬된 용액들에서 **한 용액을 선택**
4. 나머지 용액들에서 `Binary Serarch` 알고리즘을 사용하여 **두 개의 용액을 선택**
5. 3, 4번 과정에서 선택된 총 3개의 용액의 합값인 `sum`의 절댓값과 `comp` 값을 비교하여 더 낮은지 확인
6. 값이 더 낮으면은 0과 가까운 용액이므로 이때의 용액들의 값을 `elements`에 저장
7. `sum` 값이 0보다 작으면 `l`의 위치를 증가시키고, 크면은 `r`의 위치를 감소
8. 이 과정을 반복하여 최종적으로 저장된 `elements`의 값들을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    sort(sol.begin(), sol.end());
    
    // long long 최댓값이 1e18
    ll comp = 1e18; 
    vector<ll> elements;
    
    for(int i = 0; i < n - 2; i++) {
        int l = i + 1, r = n - 1;
        while(l < r) {
            ll sum = sol[i] + sol[l] + sol[r];
            
            if(comp > abs(sum)) {
                comp = abs(sum);
                elements = { sol[i], sol[l], sol[r] };
            }
            
            if(sum < 0) l++;
            else r--;
        }
    }
    
    for(auto &it : elements) cout << it << ' ';
}
```
- 각 용액의 특성값이 저장된 `sol`을 오름차순으로 정렬
- `comp`값은 세 용액의 특성값의 합산과 비교할 것으로 절댓값을 기준으로 비교하여 낮은 값일 때 갱신하도록 함.
- `i`번째 용액이 선택한 용액이고 **`i + 1`번째부터 `n - 1`번째 용액들 사이에서 `Binary Search` 알고리즘으로 두 개의 용액을 선택**
- `sum` 값에는 선택한 3개의 용액의 특성값을 합한 절댓값의 값이 `comp` 값과 비교하여 낮은지 확인
- 낮다면은 0에 더 가까운 특성값이므로 이때의 `comp`값을 갱신 및 `elements` 값에 순차적으로 `i`, `l`, `r` 번째의 특성값들을 저장
- `sum` 값이 0보다 작으면 `l`의 위치를 증가, 그 반대이면은 `r`의 위치를 감소함.
- 최종적으로 위 과정을 반복하여 확인이 끝나면 `elements`의 값을 순차적으로 출력
</details>

### 후기
- 처음할 때 숫자를 범위가 1억 범위인지 알았지만 계속해서 틀려서 확인하니 10억이었다. 이에 `long long` 으로 변환해서 다시 시도
- `else r--;` 코드를 처음에 `else if(sum > 0) r--'` 했을 때 시간초과가 발생했음. 발생원인으론, ``sum == 0`일 때는 `l`과 `r`의 증감소가 없어서 `while`문이 무한반복되어 시간초과된 것
- 처음 문제를 풀 땐, 여러 개들 중에서 3개를 선택해야 하지에 대해 막막했지만 2407번과 비슷한 구조를 생각해냄. 이에 일단 1개를 임의로 선택한 후 나머지 2개를 이분 탐색으로 하면 된다는 생각을 떠올림.