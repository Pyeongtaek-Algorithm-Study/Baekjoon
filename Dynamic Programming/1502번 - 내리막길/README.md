### 1502번: 내리막길

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1502)

**문제 조건**
- 지도는 직사각형 모양이며, 각 칸에는 높이가 쓰여 있으며, 각 지점 사이의 이동은 상하좌우로 인접한 곳끼리 가능
- 다음 칸으로 이동하는 조건은 현재 높이보다 더 낮은 지점으로만 이동

**출력**  
- 제일 왼쪽 위 지점에서 출발하여 가장 오른쪽 아래 지점까지 가는 내리막길의 경로의 개수 출력

### 풀이
1. 전형적인 `DFS`문제이지만, 지도의 최대 크기가 500 X 500이므로 모든 경로를 DFS로 살펴보면은 **시간초과 발생**
2. (0,0) 에서 출발하여 (n-1, m-1) 까지 **각 칸에 갈 수 있는 경로의 수**들을 저장
3. 즉, 좌표에서 다음 칸의 `DFS`를 하여 기존 값에 갈 수 있는 경로의 개수를 합하여 저장
4. 최종적으로 (0,0) 좌표에는 (n-1, m-1)로 갈 수 있는 경로의 최대값 저장

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
int dfs(int x, int y) {
    if(x == n - 1 && y == m - 1) {
        return 1;
    }
    
    if(vis[x][y] == -1) {
        vis[x][y] = 0;  
        for(int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            if(arr[nx][ny] >= arr[x][y]) continue;
            vis[x][y] += dfs(nx, ny);
        }
    }
    return vis[x][y];
}
```
- `dfs`를 구현하고, 좌표값이 최종적으로 가장 오른쪽 아래에 도착하면은 `return 1`
- 초기 `vis[][]`에는 각 칸에 -1을 저장하고, (x,y) 좌표 칸이 -1일 경우 다음에 갈 수 있는 칸을 조사
- `vis[x][y]` 를 0으로 초기화하고, 다음칸의 갈 수 있는 경로의 개수를 기존 값에 합함.
- `vis[x][y]`이 -1이 아니면은 이미 확인했던 경로이므로, 건너감.
- `dfs`로 (0,0)을 시작하여 (n-1,m-1)위치까지 도달하여 각 칸에는 갈 수 있는 경로의 개수들이 저장
- 최종적으로 전부 살펴보고 난 후, (0,0)에는 갈 수 있는 경로의 개수의 최대가 저장

</details>