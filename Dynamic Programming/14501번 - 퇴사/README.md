### 14501번: 퇴사

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/14501)

**문제 조건**
- 퇴사를 하려고 하는데, N+1일 째에 퇴사를 하는데, 남은 N일 동안 최대한 많은 상담을 진행
- 각 상담을 완료하는데 걸리는 기간은 T, 상담을 했을 때 받을 수 있는 금액을 P로 구성
- 상담의 기간동안에는 다른 상담을 진행할 수 없고 N+1에는 퇴사를 하므로 그 이상 걸리는 상담은 할 수 없음

**출력**  
- 입력을 주어졌을 때 퇴사날 까지 최대로 벌 수 있는 이익을 출력

### 풀이
1. 상담을 진행했던 이익에 대해 퇴사날까지 이익을 합치는 구조로 전형적인 DP문제
2. N개를 입력받을 때, `vector<pair<int, int> > v`에 정하여 pair의 first에는 기간, second에는 이익을 저장
3. Top-down방식으로 배열의 N번째부터 0까지 버는 돈으로 DP를 계산
    - n일차 일때 상담기간을 더하여 그 값이 퇴사일(N+1)보다 크면 상담을 진행할 수 없으므로, dp배열의 1칸 앞에 있는 값을 그대로 가져옴.
    - 상담 진행이 가능한 경우는 상담을 할지 또는 그대로 넘어갈지 판단하여야 한다. 이에, **dp의 1칸 앞의 값**과 **i번째의 이익+dp[i+v[i].first]위치의 값**과 비교하여 최대값을 `dp[i]`에 저장
4. i가 0일 때까지 반복하여 dp배열을 채우고, `dp[0]`에는 최대 이익이 저장

### 핵심 코드
```
void dynamicP(int n) {
    for(int i = n; i >= 0; i--) {
        if(i + v[i].first > n + 1) dp[i] = dp[i+1];
        else dp[i] = max(dp[i+1], v[i].second + dp[i + v[i].first]);
    }
}
```
- n일차의 상담기간이 퇴사날을 넘어갈 경우 상담 진행이 불가하므로 `dp[i+1]`값을 `dp[i]`에 저장
- `dp[i+1]`과 `v[i].second + dp[i + v[i].first]`를 비교하여 최대값을 `dp[i]`에 저장  
**그대로 넘어갈 것인지** 아님 **n일차에서의 이익과 n일차 상담 이후 얻는 이익 합산**을 비교하여 `dp[i]`에 저장
