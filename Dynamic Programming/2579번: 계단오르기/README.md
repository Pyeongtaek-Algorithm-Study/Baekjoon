### 2579번: 계단오르기
링크 : [계단오르기](https://www.acmicpc.net/problem/2579)
### 문제
계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.

**규칙**
1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오르기 가능하다.
2. 연속된 세 개의 계단을 밟을 수 없다. 단, 시작점은 계단에 포함하지 않는다.
3. 마지막 도착 계단은 반드시 밟아야 한다.
> 6 <- 계단의 개수  
> **10**  
> **20**  
> 15  
> **25**  
> 10   
> **20**  


따라서, 10+20+25+20=75 가 가장 큰 점수이다.

### 풀이
1. arr, dp 배열을 생성(arr은 입력 받은 계단 점수 배열, dp은 해당 계단 위치의 최댓값을 저장하는 배열)
2. 계단의 개수가 3이하일 때는 도출될 수 있는 최댓값은 고정적
  - n=1) `arr[0]`
  - n=2) `arr[0]+arr[1]`
  - n=3) `max(arr[0]+arr[2], arr[1]+arr[2])` : 첫번째+세번째 계단 vs 두번째+서번째 계단 합을 비교
3. 계단의 개수가 4이상일 때는 점화식을 통해 최댓값을 구할 수 있다.
  - arr[i]+arr[i-1]+dp[i-3] vs arr[i]+dp[i-2] 두 개 중에 최댓값으로 dp[n-1]을 구할 때 까지 반복


### 핵심코드
```
for(int i=3;i<N;i++) {
        dp[i] = max(arr[i]+arr[i-1]+dp[i-3], arr[i]+dp[i-2]);
    }
```
계단이 4이상일 경우부터 단일 for문을 통해 dp 배열에 점화식을 통해 최댓값을 저장한다.
이후에, dp배열에 n-1 행의 값을 출력하면은 정답이다.
