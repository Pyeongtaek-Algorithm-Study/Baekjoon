### 10942번: 팰린드롬

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/10942)
2. **도움 블로그** : https://velog.io/@dhelee/%EB%B0%B1%EC%A4%80-10942%EB%B2%88-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC-Python-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DDP

**문제 조건**
- 명우와 홍준이는 함께 팰린드롬 놀이를 해보려 함.
- 홍준이는 자연수 N개를 칠판에 적고, 명우에게 질문을 M번을 함.
- 각 질문은 두 정수 S와 E로 나타낼 수 있으며, S번째 부터 E번째 까지 수가 팰린드롬을 이루는 지 질문
- 명우는 각 질문에 대해 "팰린드롬이다" 또는 "아니다" 로 말함.

**출력**  
- 홍준이의 질문에 대한 명우의 답을 입력으로 주어진 순서에 따라 출력
- **팰린드롬**인 경우에는 1, 아닌 경우에는 0을 출력

### 풀이
1. 팰린드롬인지 확인하는 DP의 방법
    1. 구간이 1칸인 경우에는 그 구간은 팰린드롬
    2. 구간이 2칸인 경우에는 연속된 구간이고, 서로 값이 같으면 팰린드롬
    3. 구간이 3칸이상인 경우, 처음값과 마지막값이 같고 중간 사이 구간이 팰린드롬이면 팰린드롬
2. 위 규칙을 통해서 팰린드롬 구간 사이를 입력받으면 결과값들을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    fill_n(&dp[0][0], n * n, false);
    
    for(int i = 0; i < n; i++) dp[i][i] = true;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(i + 1 == j && num[i] == num[j]) dp[i][j] = true;
        }
    }
    for(int i = 2; i < n; i++) {
        for(int j = 0; j < n - i; j++) {
            if(num[j] == num[j + i] && dp[j + 1][j + i - 1]) dp[j][j + i] = true;
        }
    }
    
    for(auto &it : qes) {
        dp[it.X - 1][it.Y - 1] ? cout << 1 << '\n' : cout << 0 << '\n';
    }
}
```
- `dp[][]`로 초기값을 전부 `false`로 저장
- 구간 사이가 1칸이면 무조건 팰린드롬이므로 `true`로 설정
- 구간이 사이가 2칸이면 서로 붙어있으며, 값이 서로 같을 경우 팰린드롬이므로 `true`로 설정
- 구간이 사이가 3칸 이상이면, 처음값과 마지막값 사이가 같고, 중간 구간 사이를 `dp[][]`를 통해서 팰린드롬이므로 `true`로 설정
- 입력받은 구간이 `true`인 경우 1로 출력하고 아닌 경우 0으로 출력

</details>

### 후기
- 