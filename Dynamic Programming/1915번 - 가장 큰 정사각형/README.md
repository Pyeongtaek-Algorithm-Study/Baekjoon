### 1915번: 가장 큰 정사각형

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1915)
2. **도움 블로그** : https://breakcoding.tistory.com/366

**문제 조건**
- `n` X `m` 의 배열이 존재
- 배열의 각 칸에는 0, 1로 구성

**출력**  
- 배열에서 1로 된 가장 큰 정사각형의 크기를 출력

### 풀이
1. 2차원 배열인 `arr`과 `dp`의 값을 저장할 배열 선언
2. 정사각형의 최대 값을 저장할 `max_side` 선언
3. `arr`의 값을 저장할 때 각 줄을 문자열로 입력받아 숫자로 각 배열의 칸에 저장
4. `dp[][]` 에서 가장 윗줄 과 좌측은 0으로 설정 _(`fill\_n`을 사용하여 배열에 0으로 초기화)_
5. `dp[][]` 에서 `arr[][]` 값이 0이면은 0으로 저장, 만약 1이면은 area() 실행
    1. `area()`는 `dp[][]` 값을 저장할 때 좌측 상단에서 우측 하단까지의 정사각형을 파악하여 최대 변의 길이를 저장
    2. `[i][j]` 위치의 최대 가능 변의 길이는 `[i-1][j], [i-1][j-1], [i][j-1]` 이 3개의 최솟값을 구한 후 1을 더한 값
    3. _쉽게 생각하면은, 해당 칸의 값을 조사할 때 좌측 상단 방향으로 **2 X 2** 값을 조사하여 최솟값에 1을 더한 값이 정사각형의 한 변 길이_
6. 순차적으로 배열을 돌아서 `max_side` 값에 최댓값을 갱신
7. 정사각형의 넓이는 한 변의 제곱이므로 `max_side` 값을 2 번 곱한 값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
int area(int i, int j) {
    int side = min(min(dp[i-1][j], dp[i-1][j-1]), dp[i][j-1]) + 1;
    max_side = max(max_side, side);
    return side;
}

void solve() {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(arr[i][j]) {
                dp[i+1][j+1] = area(i+1, j+1);
            }
        }
    }
    
    cout << max_side * max_side << '\n';
}
```
- for문을 통하여 `arr[i][j]` 값을 확인하여 1일 경우에 `dp[][]` 에 `area()` 함수를 실행하여 값을 반환 받음
- `dp[i+1][j+1]`을 하는 이유는 입력받은 값인 `arr[][]`은 0 ~ `n - 1`, 0 ~ `m - 1`, 이지만 `dp[][]`에 저장할 땐 1 ~ `n`, 1 ~ `m` 에 저장

_`area()`에서 값을 입력 받을 때, 2 X 2 를 조사할 때 -1 위치 만큼을 염두해야 하므로_
- `side` 에 좌측, 좌측 상단, 상단의 3개의 최솟값을 구한 후 + 1 한 값을 `dp[][]`에 저장
- `max_side` 값에는 `side` 값과 비교하여 최댓값을 저장
- 최종적인 `max_side` 값을 구한 후, 제곱 한 값을 출력
</details>

### 후기
- 브루트 포스로 **1 ~ (가로 세로의 중 작은값)** 까지 칸을 다 확인하여 정사각형이 있는지 체크를 할려고 하니, 시간초과가 날 것으로 예상
- **2 X 2** 값을 기준으로 슬라이딩 윈도우처럼 체크를 하여 정사각형의 최댓 값을 구할 수 있는 것이 신기했다.