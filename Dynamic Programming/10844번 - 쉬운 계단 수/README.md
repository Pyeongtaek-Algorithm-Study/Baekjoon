### 10844번: 쉬운 계단 수

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/10844)
2. **도움 블로그** : https://ssinee.tistory.com/entry/%EB%B0%B1%EC%A4%80-10844%EB%B2%88-%EC%89%AC%EC%9A%B4-%EA%B3%84%EB%8B%A8-%EC%88%98-CDP

**문제 조건**
- N개의 자릿수의 양수에서 각 자리에서 **인접한 양 옆의 숫자가 차이가 1씩 차이**나는 것을 계단 수라고 정함  
_45656 은 각 양 옆 수의 차이가 1씩 이므로 계단 수_
- 0으로 시작하는 수는 계단 수가 아님

**출력**  
- **N개의 자릿 수**에서 계단 수가 총 몇 개 있는지 1,000,000,000으로 나눈 나머지를 출력

### 풀이
1. 1자리 수의 계단의 수는 1, 2, ..., 9로 총 9개
2. 2자리 수의 이상의 계단 수부터는 맨 앞자리는 1 ~ 9의 수지만, 맨 뒷자리는 0 ~ 9로 총 10개가 존재
3. 맨 뒷 자리를 기준으로 **점화식을 도출**하도록 함
4. 2 ~ 8 의 맨 뒷자리 숫자일 경우 **해당 자릿 수의 - 1의 인접한 수들** 계단 수 개수의 합을 구하면 됨   
_ex. 3자리 수와 맨 뒤가 2인 경우, 2자리 수일 때의 계단 수로 2의 인접한 1과 3의 각각의 계단 수의 합이 곧 3자리 수의 맨 뒤가 2인 계단 수 개수_
5. 단, 2 ~ 8일 경우에는 각각 인접한 수가 2개씩 이지만, **0과 9는 인접한 수가 각각 1과 8**밖에 없음
6. 0일 때는 해당 자릿 수 - 1의 맨 뒷 숫자가 1인 계단 수이고, 9일 떄는 맨 뒷 숫자가 8인 계단 수가 해당 개수들임
7. 따라서 `i`개의 자릿 수이고, 맨 뒷 숫자가 `j`($2<=j<=8$)일 때 `dp[i][j]` 라는 값일 때, `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]` 라는 점화식
8. `i`개의 자릿수이고, 맨 뒷 숫자가 0과 9일 떄는 각각 `dp[i][0] = dp[i-1][1]`, `dp[i][9] = dp[i-1][8]` 라는 점화식들이 도출
9. 위 점화식을 이용하여 `n`개의 자릿수까지를 반복

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    for(int i = 1; i < 10; i++)
        dp[1][i] = 1;
    for(int i = 2; i <= n; i++) {
        for(int j = 0; j < 10; j++) {
            if(j == 0) 
                dp[i][0] = dp[i-1][1];
            else if(j == 9) 
                dp[i][9] = dp[i-1][8];
            else 
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1];
            
            dp[i][j] %= 1000000000;
        }
    }
    int ans = 0;
    for(int i = 0; i < 10; i++)
        ans = (ans + dp[n][i]) % 1000000000;
        
    cout << ans << '\n';
}
```
- `dp[i][j]`는 `i`개의 자릿 수일 때 맨 뒷 숫자가 `j`일 때의 계단 값의 개수를 의미
- 1개의 자릿 수 일떄는 1 ~ 9 로 1개씩이므로 각각 `dp[1][]` 에 값에 1씩이 저장(단순 0은 계단 수 X)
- 2개 자릿 수 이상일때는 맨 뒷자리가 0일 때는 이전 개수의 맨 뒷자리가 1인 경우가 계단 수 - `dp[i][0] = dp[i-1][1]`
- 맨 뒷자리가 9일 떄는 이전 개수의 맨 뒷자리가 8인 경우가 계단 수 - `dp[i][9] = dp[i-1][8]`
- 맨 뒷자리가 그 외인 경우는 이전 개수의 긱긱 인접한 계단 수의 합 - `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]`
- 위 과정을 계산 한 후에 **10억으로 나눈 값**을 저장  
_매 과정마다 10억으로 나눈 후 최종 값에도 10억으로 나눈 이유는 아래의 모듈러 산술 법칙을 확인하면 이해 가능_
</details>

### 후기
- 왜 계산 때마다 나머지로 저장했는지 의문이 었는데 **모듈러 산술 연산**의 특징 떄문
- 보다 자세한 내용은 [모듈러 산술 법칙](https://sskl660.tistory.com/75) 의 링크로 확인 바람