### 1932번: 정수 삼각형

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1932)

**문제 조건**
- 삼각형의 맨 위부터 아래로 내려올 때, 내려온 경로의 합이 최대로 되는 경로 찾기
- 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 오른쪽에 있는 것에서 선택
- 삼각형의 크기는 $1 ≤ n ≤ 500$, 각 수는 $9999$이하의 양의 정수

**출력**  
- 합이 최대가 되는 경로에 있는 수의 합을 출력

### 풀이
1. 삼각형의 크기가 500이므로, 이중 반복문을 통해서 풀 수 있었다.
2. `arr[][]`과 `dp[][]`을 선언하여 입력값을 저장
3. 다음층의 왼쪽과 오른쪽의 합을 현재층까지 합은 `dp[][]`과 다음층 수는 `arr[][]`으로 합하여 최대값을 비교
4. `dp[][]`에 마지막까지 계산한 후에, 마지막 층에 값들 중 최댓값을 출력 

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solution() {
    int ans = 0;
    
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < i + 1; j++) {
            dp[i+1][j] = max(dp[i+1][j], dp[i][j] + arr[i+1][j]);
            dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + arr[i+1][j+1]);
        }
    }
    
    for(int i = 0; i < n; i++) {
        ans = max(ans, dp[n-1][i]);
    }
    
    cout << ans << '\n';
}
```
- `dp[i+1][j]` 와 `dp[i+1][j+1]`은 현재층 기준으로 각각 아래층의 왼쪽과 오른쪽
- `max()`을 이용하여 `dp[i][j]`의 현재층과 `arr[][]`에 적혀있는 왼쪽, 오른쪽 값을 각각에 맞는 위치에 비교하여 최대값을 저장
- `dp[][]`에 순환을 한 후에, 마지막층(`n-1`)에 최대값을 `ans`에 저장 후 출력  

</details>