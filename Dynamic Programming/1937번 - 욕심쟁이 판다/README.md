### 1937번: 욕심쟁이 판다

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1937)
2. **도움 블로그** : 

**문제 조건**
- n X n의 크기의 대나무 숲이 있으며 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작
- 판다는 해당 지역에서 대나무를 다 먹고 나면 상하좌우 중 한 곳으로 이동하고 대나무를 먹음
- 단, 판다는 욕심이 많기 때문에 자리를 옮길 때 마다 이전 지역보다 대나무를 더 많이 먹음

**출력**  
- 사육사는 욕심쟁이 판다를 어느 지역에 풀어 놓아야 **판다가 이동할 수 있는 최댓값의 칸 수**를 출력

### 풀이
1. 욕심쟁이 판다가 시작하는 위치부터 1부터 셀 수 있다.
2. 욕심쟁이 판다가 시작할 수 있는 위치를 전부 조사한 후에 각각의 위치에서 최댓값을 구해본다.
3. 이동할 수 있는 최댓값은 _DFS_ 를 이용하여 현재위치에서 다음위치의 대나무의 개수를 비교하여 더 클때만 _DFS_ 탐색을 한다.
4. `dp[][]` 배열에는 해당위치에서 이동가능한 최댓값을 저장해놓는 용도로 저장
5. 한칸 한칸 욕심쟁이 판다의 시작위치를 순환하면서 `result` 값의 최댓값을 갱신
6. 판다가 시작할 수 있는 위치를 전부 다 확인하고 난 후, `result` 값에는 최댓값이 저장되어있으므로 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
int dfs(int x, int y) {
    if(dp[x][y]) return dp[x][y];
    dp[x][y] = 1;
    for(int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx >= 0 && nx < n && ny >= 0 && ny < n && forest[nx][ny] > forest[x][y]) {
            dp[x][y] = max(dp[x][y], dfs(nx, ny) + 1 );
        }
    }
    
    return dp[x][y];
}
```
- `dp[][]` 값에는 0이 아니라면 해당 위치의 최대 이동 칸수가 적혀 있으므로 해당값을 반환
- 처음 방문한 위치라면 해당 `dp[][]` 위치에서 1로 저장 (처음 시작할 위치는 1)
- 숲 내에서 다음칸의 대나무 수가 더 많은 곳이 있으면 기존 `dp[][]` 값과 **다음칸 이동 가능 수 + 1 값**과 비교하여 최댓값을 갱신
- 위 과정을 _DFS_ 로 반복
- 최종적인 해당 위치의 `dp[][]` 값을 구하고 난 후 함수값을 반환
</details>

### 후기
- `dp[][]` 배열을 통해서 해당 위치의 최대 이동 수를 저장하는 아이디어
- `dfs()`의 반환값을 정수로 하여 `dp[][]` 값 저장과 `result` 값을 바로 최댓값을 비교할 수 있었음