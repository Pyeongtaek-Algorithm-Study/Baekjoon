### 2193번: 이친수

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/2193)

**문제 조건**
- 이친수는 0으로 시작하지 않는다. 이친수에는 1이 두번 연속으로 나타나지 않는다.(11을 부분 문자열로 갖지 않는다.)

**출력**  
- N자리 이친수의 개수를 출력하시오.

### 풀이
1. 이친수는 N자리만큼 작성하면 아래와 같다.
    1. 1 (1개)
    2. 10 (1개)
    3. 100, 101 (2개=1자리+2자리)
    4. 1000, 1001, 1010 (3개=2자리+3자리)
    5. 10000, 10001, 10010, 10100, 10101 (5개=3자리+4자리)  
    _(피보나치 수열과 같은 것을 알 수 있다.)_
2. 이전 N자리 수에 맨 뒤에 0 또는 1을 붙여서 가능한 개수는 피보나치와 같다.
3. DP를 이용하여 `dp[i] = dp[i-1] + dp[i-2]` 점화식으로 배열을 생성한 뒤 해당 번째 배열 값을 출력한다.
4. 피보나치의 47번째 부터 `int`형을 초과하므로 `long long` 타입으로 `dp`를 저장해야 한다.

### 핵심 코드
```
long long  dp[91];

dp[0] = 1;
dp[1] = 1;
for(int i = 2; i < n; i++) {
    dp[i] = dp[i-1] + dp[i-2];
}
cout << dp[n-1] << "\n";
```
- `dp[0]` 부터 시작하여 채운다. 0번째와 1번째는 각각 1로 시작.
- `dp[2]` 부터 점화식을 이용하여 값을 저장
- N번째는 배열의 `N-1`값을 출력