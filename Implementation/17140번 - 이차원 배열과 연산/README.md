### 17140번: 이차원 배열과 연산

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/17140)
2. **도움 블로그** : https://m.blog.naver.com/zbqmgldjfh/222602791094

**문제 조건**
- 크기가 3 X 3인 배열 A가 있으며, 1초가 지날때마다 배열의 연산이 진행(시작 인덱스는 1)
    - R연산 : 배열 A의 모든 행에 대해서 정렬 수행(행 개수 >= 열 개수)
    - C연산 : 배열 A의 모든 열에 대해서 정렬 수행(행 개수 < 열 개수)
- 모든 행 또는 열에 대해 정렬을 진행하려면, 각 행, 열에서 수가 몇 번 나왔는지 알아야 함.
- 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지만 수가 커지는 순으로 정렬
- 그 다음 배열 A에 정렬된 결과를 다시 그 행과 열에 대입
- 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수 모두 넣으며 순서는 수를 먼저 넣음
- 졍렬된 결과를 배열에 넣으면 행 또는 열의 크기가 변경될 수 있어 R연산 후 C연산이 진행될 수 있음
- 각 행과 열의 크기는 모든 형과 열의 크기에서 가장 큰 값을 기준으로 하고 부족한 부분은 0으로 채우고, 0은 세지 않음
- 행과 열의 크기가 100을 넘어가는 경우, 처음 100개를 제외한 나머지는 버림

**출력**  
- A[r][c]에 들어있는 값이 k가 되기 위한 배열의 연산의 최소 시간을 출력
- 100초가 지나도 k값이 되지 않을 경우 -1을 출력

### 풀이
1. R연산과 C연산은 각 행과 열의 크기에 따라서 어느 연산이 실행되는지만 다르고, 과정은 비슷  
   즉, 연산 과정을 **행과 열을 반대로만 진행하는 것**과 같음
2. 행을 기준으로 R연산으로 설명 진행
3. 행의 개수가 열의 개수보다 크거나 같을 경우 배열의 각 행을 조사
4. 배열의 각 행에서 수의 개수들을 센 후에, 수의 개수가 1이상 일 시에 **(수의 개수, 수)**를 리스트에 담아놓음
5. 리스트에 담아놓은 것들을 수를 기준으로 **오름차순으로 정렬**  
   _※ 문제 조건의 정렬의 해석이 어렵지만, 쉽게 풀면 첫번째로 수의 개수를 오름차순, 수의 개수가 같을 경우 수를 오름차순이란 뜻_
6. 오름차순으로 정렬된 (수의 개수, 수)를 각각 기존 배열의 행에 입력
7. 해당 행의 길이는 곧 리스트의 담겨진 원소들의 X 2한 만큼이 길이  
   _※ 한 원소당 (수의 개수, 수)임으로 2개의 길이를 가짐_
8. 모든 행마다 위 과정들을 반복해서 **가장 큰 행의 길이가 기준**임으로 행의 길이를 반환
9. C연산도 과정은 같으므로, 행과 열만 기준을 바꿔서 진행
10. 위 과정을 입력받은 위치의 값이 `k`가 될 때까지 반복하며, **100초 이내로 될 경우 해당 시간**을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
int change(int a, int b, bool is_row) {
    int count_num[MAX] = { 0, };
    int max_len = 0;
    
    for(int i = 0; i < a; i++) {
        fill_n(&count_num[0], MAX, 0);
        vector<pair<int, int> > bucket;
        
        for(int j = 0; j < b; j++) {
            if(is_row) {
                count_num[arr[i][j]]++;
            }
            else {
                count_num[arr[j][i]]++;
            }
        }
        
        for(int j = 1; j < MAX; j++) {
            if(count_num[j] > 0) {
                bucket.push_back({count_num[j], j});
            }
        }
        
        int len = bucket.size();
        max_len = max(max_len, len * 2);
        sort(bucket.begin(), bucket.end());
        int idx = 0;
        
        for(int j = 0; j < MAX; j++) {
            if(is_row) {
                arr[i][j] = 0;
            }
            else {
                arr[j][i] = 0;
            }
        }
        
        for(int j = 0; j < len; j++) {
            if(is_row) {
                arr[i][idx++] = bucket[j].second;
                arr[i][idx++] = bucket[j].first;
            }
            else {
                arr[idx++][i] = bucket[j].second;
                arr[idx++][i] = bucket[j].first;
            }
        }
    }
    return max_len;
}
```
- 연산을 진행할 `change()`로 `a`, `b`는 각각 행과 열의 길이, `is_row`는 R연산인지 C연산인지를 결정하는 매개변수
- `count_num[]`은 각 행(또는 열)에서 숫자들의 개수를 기록한 배열, `max_len`은 해당 행 또는 열의 길이가 가장 큰 값을 저장할 변수
- 각 행(또는 열)마다 진행할 것으로 `count_num[]`을 0으로 초기화 후, 각 자리를 확인하여 수가 있을 경우 **해당 수의 개수 증가**
- `bucket`은 (수의 개수, 수)를 담을 임의의 배열로, 수의 개수가 존재할 시에 해당 값들을 저장 후 오름차순 정렬
- 해당 행의 길이는 `bucket의 크기 X 2`한 값과 동일하고 `max_len`에 행의 길이와 비교하여 더 큰 값을 저장
- 기존 행에다가 `bucket`에 있는 각 원소들을 저장해야 함으로, `idx` 변수로 알맞은 위치에 값을 저장
- 정렬은 (수의 개수, 수) 순으로 정렬했지만, 배열에 저장할 때는 정렬된 것에 **(수, 수의 개수) 순으로 저장**해야 함.
- 위 과정을 모든 행(또는 열)을 진행한 후에 가장 큰 값이 저장된 `max_len`을 반환
</details>

### 후기
- 배열 가로 세로 각각 100이하까지만 저장하라고 조건문을 걸진 않았지만 통과되는 걸로 봐선 테스트케이스에서 100이상 넘어가는 경우가 없는 것 같음
- 문제 이해하는 것으로도 충분히 어려웠음
- 처음에는 기존 R연산과 C연산을 각각 구현했지만 GPT에게 **리팩토링**을 부탁한 결과, `is_row`를 통해 같은 코드 연산을 행과 열을 반대로 할 수 있게 했음