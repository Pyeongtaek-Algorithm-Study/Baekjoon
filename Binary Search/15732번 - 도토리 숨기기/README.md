### 15732번: 도토리 숨기기

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/15732)
2. **도움 블로그** : https://doorrock.tistory.com/58

**문제 조건**
- 1등 상금으로 도토리 D개를 받은 욕심많은 다람쥐는 자신의 모든 도토리를 뺏기지 않게 보관
- 1부터 N까지 번호가 붙여있는 N개의 상자를 이용해 도토리를 넣어 다른 다람쥐들이 찾지 못하게 숨기려 함
- 상자가 너무 많아 도토리가 있는 상자들을 모두 외울 수 없어서 **특별한 규칙**을 통해 도토리를 특정 상자에 담음
- K개의 규칙이 있어 각 규칙 당 **A번 부터 B번 상자까지 C의 간격**으로 해당 도토리에 넣을려고 함(한, 규칙당 해당 상자에 1개씩 넣는 것을 의미)
- 상자에 들어갈 수 있는 도토리의 개수는 제한이 없으며, 앞의 상자부터 넣을 수 있는 제한의 도토리만큼 **가득** 채우면서 나감

**출력**  
- D개의 도토리를 규칙에 맞게 상자 앞에서부터 넣었을 때 **마지막 도토리가 들어가는 상자의 번호**를 출력

### 풀이
1. 도토리는 10억까지가 최댓값이므로 `long long` 타입으로 선언
2. 첫번째 상자부터 마지막 상자까지 각각의 상자에서 해당 상자까지 들어갈 수 있는 도토리 값들을 구할 것
3. 무작정, 처음부터 마지막 상자까지 누적합으로 해당 상자까지의 도토리의 총합을 구하면은 최악의 테스트 케이스애선 **시간초과** 발생
4. 따라서, _Binary Search_ 을 통해서 특정 상자를 선택한 다음에 해당 상자까지 넣을 수 있는 도토리 총합을 구함
5. 만일 해당 상자까지 넣을 수 있는 도토리 총합이 넣어야 할 도토리인 `D`값보다 작으면은 왼쪽을 가리키는 위치를 증가시킴
6. 반대인 경우는 오른쪽을 가리키는 위치를 감소
7. 위 과정을 반복하여 _Binary Search_ 로 도토리를 다 넣을 수 있는 **상자들의 번호 중 최솟값**을 출력  
   _해당 최솟값이 결국에 규칙에 넣을 수 있는 상자 번호가 됨_

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int l = 0, r = n;
    int mid = 0, res = 0;
    
    while(l <= r) {
        ll sum = 0;
        mid = (l + r) / 2;
        
        for(int i = 0; i < k; i++) {
            int last = min(mid, rule[i][1]);
            if(last >= rule[i][0]) sum += (last - rule[i][0]) / rule[i][2] + 1;
        }
        
        if(sum >= d) {
            res = mid;
            r = mid - 1;
        }
        else {
            l = mid + 1;
        }
    }
    
    cout << res << '\n';
}
```
- `l`은 왼쪽 위치, `r`은 상자의 오른쪽 위치, `sum`은 해당 상자위치까지의 도토리 누적합
- `last` 값에는 `mid`와 `i`번째 규칙의 마지막 박스 위치 값과 비교하여 더 작은 값을 저장
- `last` 값이 `i`번째 규칙의 시작 박스 위치값보다 크면은 해당 규칙에 담을 수 있는 박스 들이 있으므로 `sum` 값에 합산
- 구한 `sum` 값과 `d` 값을 비교하여 이분 탐색 진행
- 위 과정을 반복하여 최종적으로 구한 `res` 값을 출력
</details>

### 후기
- 처음에 선언한 규칙들로 각 박스에 누적합으로 담을 수 있는 도토리를 해서 이분 탐색으로 `D` 값을 찾았지만 시간초과 발생
- 처음 방법에서 반대로 이미 임의의 `mid` 박스 번째의 도토리 누적합을 구해서 비교해서 **가능한 박스 위치의 최솟값**을 찾는 것이 해결 방법
