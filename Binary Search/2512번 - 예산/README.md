### 2512번 : 최단 경로

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/2512)

**문제 조건**
- 정해진 총액 이하에서 가능한 최대의 총 예산을 배정 방법
    - 모든 요청이 배정될 수 있는 경우는 요청 금액 그대로 배정
    - 모든 요청이 배정될 수 없을 경우 **특정한 정수 상한액을 계산**하여 그 이상인 예산요청에는 상한액으로 배정하고, 상한액 이하 요청에는 금액 그대로 배정  
    _자세한 이해는 사이트 참조바람._

**출력**  
- 배정 가능한 최댓값 정수 출력

### 풀이
1. 각 지방의 예산들을 `vector<int> v` 에 추가
2. 예산들을 `sort()`를 이용하여 오름차순으로 정렬
3. 적절한 예산을 찾기 위해 `Binary Search` 알고리즘을 활용
4. `st`에는 예산의 0원과 `end`에는 지방 예산의 최대값인 `v[n-1]`원 값 저장
5. **st와 end 합산을 2로 나누어 저장한 후에, total 변수에는 기존 지방 예산들과 비교하여 최솟값들을 찾아 합산**
6. `total` 값이 `m` 예산보다 작다면은 예산이 남는 것이므로 `st = mid + 1` 저장
7. 만일 `total`이 `m` 보다 크면은 예산보다 초과하는 것이므로 `end = mid -1` 
8. 5~7번 과정을 `st`가 `end`와 같거나 작을 때까지 반복하여 최종적인 배정 가능한 최대 예산 `end` 값 출력  

### 핵심 코드
```
sort(v.begin(), v.end());
    
int st = 0;
int end = v[n-1];
while(st <= end) {
    int total = 0;
    int mid = (st + end) / 2;
    for(auto it : v) total += min(mid, it);
    
    if(total <= m) st = mid + 1;    
    else end = mid - 1;
}
cout << end << "\n";
```
- `mid`는 `st`와 `end`의 중간값으로 저장
- `total` 에는 `mid` 값과 `v`의 각 요소와 비교하여 최솟값들을 합산하여 저장
- `total` 과 `m` 을 비교하여 예산이 남으면은 `total`을 증가 시키기 위해 `st`에 `mid + 1` 을 저장
- 예산을 초과하는 경우 `total`을 낮추기 위해 `end`에 `mid - 1` 을 저장 
