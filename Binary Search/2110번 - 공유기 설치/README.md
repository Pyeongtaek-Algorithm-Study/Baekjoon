### 2110번: 공유기 설치

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/2110)
> 도움받은 블로그 : https://wooono.tistory.com/404

**문제 조건**
- `N`개의 집이 수직선 위에 존재하고 집 여러개가 같은 좌표를 가지는 경우는 없다.
- 집에 공유기 `C`개를 설치려고 하며, 한 집에는 하나의 공유기를 설치할 수 있다.
- `C`개의 공유기를 `N`개의 집에 설치하되, 가장 인접한 두 공유기 사이의 최대 거리 구하기  
_(ex. [1] 2 [4] [8] 9에 설치하면 각 공유기 사이거리는 3과 4인데 이때 **가장 인접한 거리가 3**)_ 

**출력**  
- 설치된 공유기 중 가장 인접한 두 공유기 사이의 최대 거리 출력

### 풀이
1. 3개 이상의 공유기에서 가징 인접한 사이의 최대거리는 각 공유기가 동일한 거리이상일 때까 최대  
_ex. 1 5 9로 가운데 위치가 1과 9의 중간이여야 각 거리가 최대이다. 만일 딱 중간이 아니라면 가장 인접한 사이 거리가 4보다 작아짐_
2. 입력받은 집의 위치들을 오름차순으로 정렬
3. `mid`값으로 최소 거리와 최대 거리의 합을 2로 나눈 값
4. 첫번째 집에 공유기를 설치하는 것은 고정
5. 그 다음 집은 `mid` 값 거리 이상의 집 위치에 공유기를 설치하고 공유기 사이 거리를 `mid`값 이상씩 하여 설치할 수 있는 공유기 수를 확인
6. **설치 가능 공유기 수가 문제에서 제시한 공유기 수보다 크다면 각 공유기 사이 거리(`mid`)를 증가.**
7. **설치 가능 공유기 수가 문제에서 제시한 공유기 수보다 작다면 각 공유기 사이 거리(`mid`)를 감소**시켜 설치 가능 공유기 수를 늘릴 수 있도록 한다.

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int start = 1;
    int end = house[n - 1] - house[0];
    int result = 0;
    
    while(start <= end) {
        int mid = (start + end) / 2;
        int current = house[0];
        int count = 1;
        
        for(int i = 1; i < n; i++) {
            if(house[i] >= current + mid) {
                count++;
                current = house[i];
            }
        }
        
        if(count >= c) {
            start = mid + 1;
            result = mid;
        }
        else end = mid - 1;
    }
    
    cout << result << '\n';
}
```
- 공유기 사이 거리가 최소인 1인 `start`, 공유기 사이 거리가 최대인 마지막 집 위치 - 첫번째 집 위치
- `mid` 값은 `(start + end) / 2` 로 중간 값으로 설정
- `current`는 공유기 설치 초반이므로 첫번째 집으로 설정하고 따라서, 공유기 수는 1개로 시작
- 그 다음 공유기 설치 가능한 집을 찾기 위해 현재 집에서 `mid` 값 이상 거리에 있는 집을 찾고 공유기 설치
- 공유기를 설치가능한 집이면은 `current`값을 해당 집으로 설정하여 반복하여 공유기 설치 개수 파악
- 공유기 설치 가능 수가 문제에서 제시한 공유기 수보다 크면은 `start` 값을 `mid + 1`로 하여 다음 검사때 `mid` 값을 늘림
- 공유기 서리 가능 수가 문제에서 제시한 공우기 수보다 작다면은 `end` 값을 `mid - 1`로 하여 다음 검사때 `mid` 값을 줄임

</details>  

