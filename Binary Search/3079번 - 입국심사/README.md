### 3079번: 입국심사

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/3079)

**문제 조건**
- `N`개의 입국심사대와 `M`명의 상근이의 친구
- `N`개의 입국심사대는 각 $T_k$의 초 만큼 시간이 소요
- 한 심사대는 한 사람씩만 심사받을 수 있으며, 친구들은 원하는 심사대에서 검사를 받음.  
_심사대가 비어있다고 무조건 해당 심사대에 검사받지 않아도 됨._
- 모든 심사대에 심사를 하고 있을 경우 남은 친구들은 기다리고 있어야 함.

**출력**  
- 상근이와 친구들이 심사를 받는 시간의 **최솟값** 구하기

### 풀이
1. 단순한 생각으로 최솟값을 구하려는 방식으론 어렵
2. 입국 심사대에서 일어날 수 있는 가장 많이 걸리는 초를 구하기
3. **Binary Search방법**으로 초기에 가장 많이 걸리는 초를 `right(r)`부분, 0초를 `left(l)`부분으로 설정
4. `right`와 `left` 합의 2를 나눈 수를 `mid`값으로 설정
5. `mid`초를 기준으로 **각각의 모든 입국심사대에 받은 수 있는 인원의 총 합을 구하기**
> ex. A 심사대는 7초와 B 심사대는 10초가 걸린다고 가정, mid가 30일 때 각 심사대가 받을 수 있는 각각 인원은 30 / 7 = 4, 30 / 10 = 3 이므로 총 합은 7
6. 반복하여 해당 초에 받을 수 있는 총 인원이 `M`과 같으면서 최소 초 구하기

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    ll st = 0;
    ll end = MAX * m;
    
    while(st <= end) {
        ll sum = 0;
        ll mid = (st + end) / 2;
        for(int i = 0; i < n; i++) {
            sum += (mid / arr[i]);
            if(sum > m) break;
        }
        if(sum >= m) {
            end = mid - 1;
            ans = mid;   
        }
        else st = mid + 1;
    }
    cout << ans << '\n';
}
```
- `MAX`는 각 입국 심사대에서 걸리는 초의 최대 시간이고, `m` 인원을 곱하여 가장 많이 걸리는 시나리오 초 구하기
- Binary Search 기법을 통해 `st`가 `end`보다 작거나 같을 때까지 반복
- `mid` 값을 구하고, 해당 `mid` 초일 떄 각 심사대가 받을 수 있는 인원 구하여 총 인원 수 `sum` 구하기
- **sum이 m을 넘을 경우 반복문 중단**
- `sum`과 `m`의 대소관계를 파악하여 `mid` 값을 조정
- `mid`초일 때 상근이의 친구들이 심사를 다 받을 수 있는 최솟값인 `ans`을 찾을 떄까지 반복

</details>

### 후기
- 꽤나 큰 숫자를 다루기 때문에 최악의 시나리오에는 단순 int형으로는 overflow가 발생  
- 반복문을 통해 sum의 합을 구할 때 m보다 큰 순간에 break를 걸어야 overflow가 발생하는 것을 예방할 수 있었음.  
- 전체적으로 overflow가 발생할 수 있는 엣지 시나리오들이 있어 주의해야 했음.