### 3078번: 좋은 친구

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/3078)
2. **도움 블로그** : 

**문제 조건**
- N명 학생들의 이름이 성적순으로 주어짐.
- **좋은 친구**는 등수의 차이가 K보다 작거나 같으면서 이름의 길이가 같은 친구

**출력**  
- N명의 학생들이 성적순으로 주어졌을 때 좋은 친구가 **몇 쌍**이 있는지 출력

### 풀이
1. _Queue_ 와 _Sliding Window_ 로 풀 수 있는 문제(본 해설은 _Sliding Window_ 로 설명)
2. 친구 이름의 길이의 개수를 저장할 배열을 선언
3. 배열에 1등부터 K번 떨어진 친구까지의 이름 길이의 개수들을 각각 증가시킴
4. 처음부터 마지막 친구일 때 까지 반복하며, 자기에 해당하는 순서일 때 자기 이름 길이의 개수를 1 감소 시킴  
※ 친구를 셀 때에는 **자기 자신은 포함하지 않음.**
5. 현재 등수 이름 길이의 값을 배열에서 찾아서 결과값에 합산
6. 다음 윈도우 크기를 위해 현재 등수에서 **K + 1** 만큼 떨어진 친구의 이름 길이를 1 증가
7. 위 과정들을 반복 후, **결과값**을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    long long ans = 0;
    
    // solution 1
    for(int i = 0; i <= k; i++) cnt[stu[i].length()]++;
    
    for(int i = 0; i < n; i++) {
        cnt[stu[i].length()]--;
        ans += cnt[stu[i].length()];
        if(i + k + 1 < n) cnt[stu[i + k + 1].length()]++;
    }
    
    // solution 2
    // for(int i = 0; i < n; i++) {
    //     int len = stu[i].length();
    //     while(!Q[len].empty() && (i - Q[len].front() > k)) Q[len].pop();
    //     ans += Q[len].size();
    //     Q[len].push(i);
    // }
    
    cout << ans << '\n';
}
```
- 최악의 경우인 친구가 `n`과 `k`가 모두 30만 일 경우 출력값이 `int` 타입을 넘으므로 `long long` 타입으로 `ans`를 설정
- 1등인 친구부터 `k`번까지 떨어진 친구들의 이름의 길이를 `cnt[]`에 각각 1씩 증가
- 1등인 친구부터 차례대로 반복하며, 자기 순서일 때 자기 자신은 친구로 두지 않으므로, `cnt[]`에서 자기 이름의 길이에서 1을 뺌
- `ans`에 현재 자기 이름 길이인 친구들의 명 수를 합산
- 다음 윈도우가 `n`보다 작으면은 현재 등수에서 `k + 1` 떨어진 친구의 이름의 길이를 `cnt[]`에 1을 추가
- 위 과정을 모든 등수로 살펴본 후, 최종적으로 구한 `ans`를 출력

</details>

### 후기
- 친구의 등수 차이가 차이난다는 뜻이 자기보다 아래인 등수 친구만 둔다는 것으로,.. 윗 등수들은 친구로 안하나보다.. _(치열한 경쟁주의..)_