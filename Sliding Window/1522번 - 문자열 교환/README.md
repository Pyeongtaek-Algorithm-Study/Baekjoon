### 1522번: 문자열 교환

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1522)
2. **도움 블로그** : https://dleunji.tistory.com/208

**문제 조건**
- a와 b로만 이루어진 문자열이 존재
- 기존 문자열에서 a를 연속으로 이루어지는 문자열로 만들기 위해 임의의 두 개의 문자를 서로 교환함
- 이 문자열은 **원형**으로 처음과 끝이 인접해있음

**출력**  
- a를 연속 문자열로 만들기 위한 필요한 **교환 회수의 최솟값**을 출력

### 풀이
1. 기존 문자열에서 `a`를 모두 연속적으로 하기 위해 `a`의 개수를 구함
2. `a`의 개수를 윈도우 크기로 만들어 해당 칸에 `b`의 개수가 몇개 있는지 구함
3. 위 과정을 윈도우를 한칸씩 옮기며 해당 윈도우 내에 `b`의 개수가 최솟값인 경우를 구함
4. `b`의 개수가 최솟값일 때의 위치에서 윈도우 내 `b`와 윈도우 밖의 `a`와 서로 교환하면 `a`가 연속적 문자열이 됌.

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int a_cnt = 0;
    int str_len = str.length();
    
    for(char a : str) {
        if(a == 'a') a_cnt += 1;
    }
    
    for(int i = 0; i < str_len; i++) {
        int b_cnt = 0;
        for(int j = 0; j < a_cnt; j++) {
            if(str[(i + j) % str_len] == 'b') b_cnt += 1;
        }
        ret = min(ret, b_cnt);
    }
    
    cout << ret << '\n';
}
```
- `a_cnt`는 `a`의 개수로 윈도우 크기, `b_cnt`는 윈도우 내의 `b`의 개수를 찾는 것을 의미
- 이중 반복문을 통해 윈도우를 한칸씩 옮김
- 윈도우 내에 `b`가 존재할 때 `b_cnt`를 1씩 증가
- `ret`와 `b_cnt`를 비교하여 최솟값을 갱신
- 위 과정을 처음부터 마지막 위치까지 윈도우만큼 b의 개수를 찾아서 최종적인 결과값은 `ret`에 저장
- 결과값인 `ret` 출력
</details>

### 후기
- PS를 구상하는 것이 어려웠음. b를 어디와 교환해야 하는지로 생각했지만, 윈도우 크기를 설정한다는 아이디어 생각이 어려웠음
- Python의 경우 문자열 입력에서 `rstrip()`도 해야한다. 일부 테스트케이스에서 _'\n'_ 이 존재하여 길이 차이가 있는 듯하다.