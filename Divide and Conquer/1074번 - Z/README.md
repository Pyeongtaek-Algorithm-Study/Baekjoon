### 1074번: Z

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1074)

**문제 조건**
- 크기가 $2^N \times 2^N$인 2차원 배열을 Z 모양으로 탐색
- N > 1인 경우, 배열의 크기가 $2^{N-1} \times 2^{N-1}$로 4등분하고 재귀적으로 계속 4등분하여 순서대로 방문
![example](https://u.acmicpc.net/d3e84bb7-9424-4764-ad3a-811e7fcbd53f/Screen%20Shot%202020-12-30%20at%2010.50.47%20PM.png)
- `N`, `r`, `c`를 입력

**출력**  
- r행 c열을 몇번째로 방문하는지 출력

### 풀이
1. `solution_1()`는 분할 정복, `solution_2()`는 재귀식 풀이법이다. 
2. `N`값에 따라 배열의 크기가 다르지만, `r`, `c`의 값이 배열의 절반위치로 구분할 때 1,2,3,4사분면중에 몇 사분면에 있는지 확인한다.
3. 각 사분면의 시작위치가 아래와 같은 값으로 시작한다.  
2사분면 : $(2^{N-1})^2 * 0$   
1사분면 : $(2^{N-1})^2 * 1$  
3사분면 : $(2^{N-1})^2 * 2$  
4사분면 : $(2^{N-1})^2 * 3$
4. 각 사분면에 있는 값을 `ans`에 더한다.
5. 이제 N이 남아있다면 `r`, `c`를 각각 알맞게 반으로 나눈다.  
_기존 사분면위치에서 또 4개로 분할해서 하므로 r과 c를 위치에 맞게 반으로 나눈다._
6. `N`이 0일 때 까지 계속 분할해서 `ans`값을 더하면 최종 위치

### 핵심 코드
<details>
<summary>코드 보기</summary>

```c++
void soloution_1() {
    while(n--) {
        int half = pow(2, n);
        int value = pow(half, 2);
        
        if(r < half && c < half) {
            ans += value * 0;
        }
        else if(r < half && c >= half) {
            ans += value * 1;
            c -= half;
        }
        else if(r >= half && c < half) {
            ans += value * 2;
            r -= half;
        }
        else {
            ans += value * 3;
            r -= half;
            c -= half;
        }
    }
    
    cout << ans << endl;
}
```
- 제 2사분면은 시작이 0으로 시작하므로 `r`, `c` 값이 $2^{N-1}$ 보다 작은 값이므로 그대로 4개로 분할한다.
- 제 1사분면은 시작이 $(2^{N-1})^2*1$ 시작하므로 `ans`값에 더하고, 4개로 또 분할할 때 `c`값이 $2^{N-1}$ 크므로 2로 나눠서 진행한다.
- 제 3사분면은 시작이 $(2^{N-1})^2*2$ 시작하므로 `ans`값에 더하고, 4개로 또 분할할 때 `r`값이 $2^{N-1}$ 크므로 2로 나눠서 진행한다.
- 제 4사분면은 시작이 $(2^{N-1})^2*3$ 시작하므로 `ans`값에 더하고, 4개로 또 분할할 때 `r`, `c`값이 $2^{N-1}$ 크므로 2로 나눠서 진행한다.
- `N`을 1씩 줄이면서 최종적으로 0이 될 때 까지 `ans`에 합한다.


</details>