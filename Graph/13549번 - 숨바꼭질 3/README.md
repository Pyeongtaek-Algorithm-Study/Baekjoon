### 13549번 - 숨바꼭질 3

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/13549)
2. **도움 블로그** : https://www.acmicpc.net/board/view/144960

**문제 조건**
- 수빈이는 동생과 숨바꼭질 놀이
- 수빈이는 걷거나 순간이동을 할 수 있어 현재 위치가 X이면 1초 후엔 X-1, X+1로 이동할 수 있고, 순간이동으로 0초 후엔 2*X 위치로 이동함

**출력**  
- 수빈이가 있는 위치와 동생이 있는 위치가 주어졌을 때, 수빈이가 동생을 찾는 **가장 빠른 시간**을 출력

### 풀이
1. 이전 숨바꼭질과 다르게 순간이동을 0초로 가능
2. 이는 기존 풀이들이 BFS에서 가중치가 1도 있지만 0도 있는 것
3. 따라서 이번 문제는 _0-1 BFS_ 로 가중치가 0일 때는 일반 BFS의 queue에 뒤에 값을 넣는 것처럼이 아닌 **앞**에 넣어야 함.
4. 그 외의 경우는 동일 하게 뒤에 값을 넣어서 동생의 위치가 나올 때까지 반복
5. 나머지 구조는 BFS와 동일하게 설명은 건너뜀

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    deque<int> dq;
    dq.push_front(n);
    vis[n] = 0;
    
    while(!dq.empty()) {
        int cur = dq.front();
        dq.pop_front();
        
        for(int nxt : {cur * 2, cur - 1, cur + 1}) {
            if(nxt < 0 || nxt >= 100001 || vis[nxt] != -1) continue;
            
            if(nxt == cur * 2) {
                vis[nxt] = vis[cur];
                dq.push_front(nxt);
            }
            else {
                vis[nxt] = vis[cur] + 1;
                dq.push_back(nxt);
            }
        }
    }
    
    cout << vis[k] << '\n';
}
```
- 수빈이가 움직인 위치를 기억할 `dq`를 선언
- 수빈이의 시작 위치 또는 순간이동일 때는 가중치가 0이므로 `push_front()` 로 다음 위치를 앞에 추가
- 현재 위치에서 다음 위치로 움직일 수있는 경우의 수는 좌, 우, 순간이동으로 3가지
- 다음 위치가 이동할 수 없거나 처음 방문하는 것이 아닐 경우 건너뜀
- 다음 위치가 순간이동의 경우 `dq`에 앞에 값을 넣고 다음 소요 시간은 현재 시간과 동일
- 그 외의 좌, 우 이동은 `dq`에 뒤에 값을 넣고 다음 위치는 현재 위치 소요 시간의 +1 을 함
- 위 과정을 `vis[]`을 채울 때까지 진행 후, 동생 위치의 **소요 시간**을 출력
</details>

### 후기
- 0-1 너비 우선 탐색이라는 것을 알게됨 ( 가중치가 0인 것이 존재 )
- if문을 동시에 여러개 쓸 때 or 조건이라는 것을 자꾸 and로 헷갈려버림
- 이 문제에서는 수빈이가 동생을 찾을 수 있는 테스트 케이스만 주는듯 함.