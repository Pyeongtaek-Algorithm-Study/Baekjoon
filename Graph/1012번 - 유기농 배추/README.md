### 1012번: 유기농 배추

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1012)

**문제 조건**
- 테스트 케이스의 개수 T가 주어진다. 그 다음줄 부터 각 테이스 케이스에 대해 배추밭의 가로길이 M, 세로길이 N, 배추가 심어져있는 K
- 배추흰지렁이는 인접한 배추로 이동할 수 있으며, 이 배추흰지렁이는 해당 배추영역을 보호

**출력**  
- 각 케이스에 대한 **최소의 배추흰지렁이의 마리 수**를 출력

### 풀이
1. 최소의 배추흰지렁이를 찾기 위해선 해당 배추가 인접한 영역의 개수를 구한다.
2. 각 영역을 구하기 위해 DFS 이용한다.
3. `farm` 배열을 돌면서 배추가 있는 부분을 찾고 `vis`을 통해 방문하지 않은 곳이면 DFS를 통해 탐색한다.
4. 위 방식을 반복하며 처음 방문하는 영역을 시작할 때마다 `cnt++`를 한다.
5. 해당 테스트케이스를 다 탐색하면 `cnt`를 출력하고 다음 테이스케이스로 진행한다. 

### 핵심 코드
```
for(int j = 0; j < M; j++) {
    for(int k = 0; k < N; k++) {
        if(farm[j][k] && !vis[j][k]) {
            cnt++;
            dfs({j, k});
        }
    }
}

void dfs(pair<int, int> p) {
    vis[p.X][p.Y] = 1;
    for(int i = 0; i < 4; i++) {
        int nx = p.X + dx[i];
        int ny = p.Y + dy[i];
        if(nx < 0 || nx > M || ny < 0 || ny > N) continue;
        if(farm[nx][ny] && !vis[nx][ny]) dfs({nx, ny}); 
    }
}
```
- 반복문을 통해서 `farm[][]`에서 배추가 있으며, `vis[][]`에서 탐색하지 않은 지역일 경우 `dfs`로 탐색
- dfs함수에서는 `vis[][]`을 통해 방문기록을 남김.  
_(dfs 매개변수로 `pair`를 사용했음. 사용한 이유는 코드연습해보고 싶어서 그냥 사용해봤음)_
- 해당 좌표에서 주변에 인접한 배추지역을 탐색하기 위해 `dx, dy`를 통해 `nx, ny` 값을 조절하며 찾음. 
- `nx, ny` 가 배추밭 영역을 넘지 않고, 배추가 있는 좌표이며 방문하지 않는 곳이면 재귀적으로 `dfs`돌며 반복 
