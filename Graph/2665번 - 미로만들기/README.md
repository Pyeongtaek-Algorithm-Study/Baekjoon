### 2665번: 미로만들기

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2665)
2. **도움 블로그** : https://hagisilecoding.tistory.com/111

**문제 조건**
- n X n 바둑판 모양으로 총 $n^2$ 개의 방이 존재 
- 일부 방은 검은 방이고 나머지는 모두 흰 방이며 검은 방으로는 갈 수 없지만 붙어 있는 흰 방끼리는 지나갈 수 있음
- 윗줄 맨 왼쪽 방은 시작방으로 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로 역시 흰 방
- 시작방에서 끝방으로 가는 것이 목적이나, 검은 방으로 인해 갈 수 없는 경우가 있음
- 몇개의 검은 방을 흰 방으로 바꿔야 끝 방으로 갈 수 있는 경우가 존재
- 0은 검은 방을, 1은 흰 방을 의미

**출력**  
- 방의 모양을 주어졌을 때 시작방에서 끝방까지 도달하기 위한 **검은 방을 흰 방으로 바꿔야하는 최솟값**을 출력

### 풀이
1. 일반적인 _BFS_ 에서는 다음 칸이 검은 방일 경우 해당 경로를 제외하지만, 이 문제에서는 방을 바꿀 수 있으므로 해당 경우를 파악해야 한다.
2. 간단하게 말하자먼, 시작방에서 끝방까지 _BFS_ 로 확인하되, 검은 방을 만날 때마다 해당 경로에 검은방을 최소 몇개를 바꿨는지를 파악
3. `vis[][]`은 해당 칸까지의 검은 방의 변경 횟수를 저장하는 배열로, 초기 각 칸에는 임의의 큰 수를 저장
5. 다음 칸이 흰방일 경우는 그냥 갈 수 있는 것이므로, 다음 칸의 값이 현재 값과 더 크면 현재 값으로 저장
6. 다음 칸이 검은방일 경우 그냥 갈 수 없고 흰방으로 변경한 것이므로, 다음 칸의 값이 현재 값 + 1과 비교하여 더 작은 값으로 저장
7. 이를 끝 방까지 반복하면은 각 칸에 저장된 값은 **해당 경로까지 바꿔야하는 검은 방의 횟수의 최솟값**들이 저장
8. 최종적으로, 끝 방의 위치의 값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void BFS() {
    Q.push({0, 0});
    vis[0][0] = 0;
    
    while(!Q.empty()) {
        pair<int, int> cur = Q.front(); Q.pop();
        
        for(int i = 0; i < 4; i++) {
            int nx = cur.X + dx[i];
            int ny = cur.Y + dy[i];
            if(nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
            if(room[nx][ny] == 1 && vis[nx][ny] > vis[cur.X][cur.Y]) {
                vis[nx][ny] = vis[cur.X][cur.Y];
                Q.push({nx, ny});
            }
            else if(room[nx][ny] == 0 && vis[nx][ny] > vis[cur.X][cur.Y] + 1) {
                vis[nx][ny] = vis[cur.X][cur.Y] + 1;
                Q.push({nx, ny});
            }
        }
    }
}
```
- 일반적인 BFS 함수와 일부 동일
- 다음 칸이 흰 방인 1이면, 다음 칸의 값과 현재 칸의 값과 비교하여 더 작은 값을 다음 칸의 값에 저장
- 다음 칸이 검은 방인 0이면, 다음 칸의 값과 현재 칸의 값 + 1과 비교하여 더 작은 값을 다음 칸의 값에 저장  
_다음 칸이 검은 방이므로 변경 횟수가 + 1이 된 것이므로_
</details>

### 후기
- 검은 방을 백트래킹처럼 바꾸면서 브루트포스로 해버리면은 문제가 매우 어렵
- 일종의 _DP_ 처럼 `vis[][]`에는 변경해야 하는 검은방의 최소 횟수를 저장하는 아이디어를 구성해야 했음