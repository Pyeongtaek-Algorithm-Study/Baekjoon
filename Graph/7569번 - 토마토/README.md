### 7569번: 토마토

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/7569)
2. **도움 블로그** : https://velog.io/@falling_star3/%EB%B0%B1%EC%A4%80Python-7569%EB%B2%88-%ED%86%A0%EB%A7%88%ED%86%A0

**문제 조건**
- 토마토를 보관하는 3차원읠 창고가 존재
- 토마토에서 잘 익은 것도 있으며, 아직 익지 않은 토마토가 존재함
- 하루가 지나면은 잘 익은 토마토과 인접한 토마토들이 익게 된다. (인접한 위치 : 위, 아래, 왼쪽, 오른쪽, 앞, 뒤)
- 익은 토마토는 1, 익지 않은 토마토는 0, -1은 토마토가 들어있는 않은 칸을 나타냄

**출력**  
- 창고에 있는 토마토를 주어졌을 떄, **최소 며칠을 보관해야 창고에 있는 토마토들이 전부 익는지** 출력
- 만일, 토마토가 전부 익을 수 없는 상황이면 -1을 출력

### 풀이
1. 창고에 있는 토마토들의 상태를 저장할 `warehouse[][][]`과 _BFS_ 로 방문상태를 나타낼 `vis[][][]` 선언
2. _BFS_ 를 구현하고, 위치를 담을 `queue<pair<int, pair<int, int>>>` 타입을 선언
    - `pair`에서 순서대로 창고의 높이, 창고의 세로, 창고의 가로를 저장
3. `warehouse`의 토마토 상태를 저장할 때 만일 해당 칸에 익은 토마토일 시에 해당 위치를 `Q`에 넣기
4. `Q`가 완전히 빌 때 까지 _BFS_ 탐색을 반복
5. _BFS_ 를 통해 완전히 탐색을 한 후에, `warehouse[][][]`에 저장된 값 중 **가장 큰 값에서 1을 뺀 값**을 출력
    - 1을 뺸 이유는 날짜가 지나는 기준이 0부터 시작인데 _BFS에서 시작하는 것은 1값부터 시작하여 마지막 때 1을 뺸 값을 출력_
6. 만일, `warehouse`에서 익지 않은 토마토가 존재 시에는 해당 토마토는 주변 토마토로부터 완전히 독립되어 있어 익을 수 없는 상황이므로 -1을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void input() {
    cin >> m >> n >> h;
    for(int i = 0; i < h; i++) {
        for(int j = 0; j < n; j++) {
            for(int k = 0; k < m; k++) {
                cin >> warehouse[i][j][k];
                if(warehouse[i][j][k] == 1) Q.push({i, {j, k}});
            }
        }
    }
}

void bfs() {
    while(!Q.empty()) {
        pair<int, pair<int, int> > cur = Q.front(); Q.pop();
        vis[cur.X][cur.Y.X][cur.Y.Y] = true;
        for(int i = 0; i < 6; i++) {
            int nx = cur.Y.X + dx[i];
            int ny = cur.Y.Y + dy[i];
            int nz = cur.X + dz[i];
            if(nx < 0 || nx >= n || ny < 0 || ny >= m || nz < 0 || nz >= h) continue;
            if(warehouse[nz][nx][ny] != 0 || vis[nz][nx][ny]) continue;
            warehouse[nz][nx][ny] = warehouse[cur.X][cur.Y.X][cur.Y.Y] + 1;
            vis[nz][nx][ny] = true;
            Q.push({nz, {nx, ny}});
        }
    }
}
```
- 창고의 처음 토마토 상태를 저장하기 위해 3중 반복문으로 저장하며 익은 토마토 시에 `Q`에 추가
- `bfs()`를 호출하고 `Q`가 완전히 빌 때 까지 반복
- `nx`는 창고의 세로, `ny`는 창고의 가로, `nz`는 창고의 높이를 나타냄
- 토마토가 익은 것이 되려면 0인 값만 퍼지고 나머지는 건너뜀
- 인접한 토마토가 익은 토마토가 되는 날이 기존 위치 값에서 1을 더한 값이므로 해당 칸에 값을 저장
- 다음 칸을 `Q`에 저장하며 순차적으로 탐색
</details>

### 후기
- 처음에 _BFS_ 를 구현한 후에, 먼저 창고의 상태를 다 저장한 후 3중 for반복문을 돌면서 익은 토마토를 발견하고 _BFS_ 로 탐색했지만, 만일 **익은 토마토가 서로 떨어져있으면서 여러개가 존재 시에는 순서에 따라 값이 달라짐.**
- 이를 해결하는 방법이 창고의 상태 입력받을 때 **익은 토마토일 경우 Q에 즉각적으로 추가하여 해결**