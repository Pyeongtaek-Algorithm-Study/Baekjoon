### 2644번: 촌수계산

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2644)
2. **도움 블로그** : 

**문제 조건**
- 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현
- 부모와 자식 사이를 1촌으로 두고, 이후 사람들 간의 촌수를 계산

**출력**  
- 여러 사람들에 대한 부모 자식들 간의 관계를 주어졌을 때, 주어진 두 사람의 촌수를 계산하여 출력
- 두 사람의 친척 관계가 전혀 없을 때는 -1을 출력

### 풀이
1. 부모와 자식의 관계들을 입력받으므로 트리와 같은 구조
2. 가족들 관계를 입력받을 때 `x` -> `y`이면, `y` -> `x`인 값도 저장
3. `st`부터 출발하여 `DFS`로 순회
4. 입력받은 `s`에서 관계가 있는 `i`를 발견하면 `vis[][]`에 서로 관계에서 방문처리를 진행
5. `dfs`로 다음 가족 관계로 시작하고, `depth + 1` 값으로 시작
6. 이를 반복하며 `s`의 값이 도착하고자 하는 `en`과 같으면은 `depth`인 촌수를 출력
7. 만일 전부 순회했지만 `dfs`함수를 완전히 탈출하면은 도착하고자하는 친척과 관계가 없는 것이므로 `-1` 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void dfs(int s, int depth) {
    if(s == en) {
        cout << depth << '\n';
        exit(0);
    }
    for(int i = 0; i <= n; i++) {
        if(family[s][i] && !vis[s][i]) {
            vis[s][i] = true;
            vis[i][s] = true;
            dfs(i, depth + 1);
        } 
    }
}

void solve() {
    dfs(st, 0);
    cout << -1 << '\n';
}
```
- `dfs`에 `s`로 가족 1명을 선택되고, `s`와 관계가 있는 가족을 찾는다.
- 아직 방문하지 않고, 관계가 있는 가족을 찾으면 `vis[][]`에 기록하고, 다음 가족을 기준으로 `dfs`를 순회한다.
- `depth`는 1을 더한 값으로 하여 촌수를 증가
- `s`가 도착하고자하는 `en`값과 같으면은 `depth`인 촌수를 출력하고 종료
- 만일, `dfs`를 전부 순회했지만 `en`값을 찾지못하면은 해당 가족과는 관계가 없는 것이므로 `-1`을 출력
</details>

### 후기
- 처음에 `x` -> `y`로 가는 관계만 저장하면 서로 간의 관계를 순회하지 못했음. 이에 `y` -> `x`인 관계도 추가
- `vis[][]`에서 `x` -> `y`로 가면 `y` -> `x`도 방문 처리를 해야했음. 안그러면 다시 되돌가는데 이때 `depth`도 계속 증가돼버림