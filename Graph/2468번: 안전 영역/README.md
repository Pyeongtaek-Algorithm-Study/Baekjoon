### 2468번: 안전 영역

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/2468)

**문제 조건**
- N * N 배열에서 각 지역의 높이 정보를 제공
- 장마철로 인한 물높이에 따라 일정한 높이 이하의 모든 지점은 물에 잠김  
*ex. 물높이가 5 값일 때 높이 5 이하의 지역들은 모두 물에 잠긴다*

**출력**  
- N * N 배열을 주어졌을 때, 각 물높이별 안전 영역 개수 중 **최대값** 출력

### 풀이
1. 입력 받은 지역 중에서 **가장 높은 지역의 높이** 파악
2. 배열 돌면서 지역 중에서 **물높이보다 높은 지역을 시작 위치** 설정
3. 시작 위치를 큐에 담고, BFS를 돌면서 안전 영역의 개수를 파악
4. 이를 가장 높은 지역까지 반복하며 안전 영역의 개수를 비교해 **최대값**을 구함

### 핵심 코드
<details>
<summary>코드 살펴보기</summary>

```
for(int h = 0; h<height;h++) { 
    for(int i = 0;i<n;i++) {
        for(int j=0;j<n;j++) {
            if(area[i][j] > h && vis[i][j] == 0) {
                Q.push({i, j});
                BFS(h);
                safety++;
            }
        }
    }
    result = max(result, safety);
    reset();
}
```

- 지역 중에서 가장 높은 지역인 height까지 반복적으로 안전 영역을 구하기 위해 `BFS 함수` 반복
- `area[i][j]` 위치가 물높이보다 높고, 방문하지 않은 지역을 큐에서 시작 위치로 설정
- 해당 `BFS 함수`를 마치면은 하나의 안전 영역을 찾은 것이므로 `safety++`로 개수 증가
- 기존 최대값(result)와 safety값을 비교하여 최대값 찾기

```
void reset() {
    safety = 0;
    for(int i=0;i<n;i++) {
        for(int j=0;j<n;j++) {
            vis[i][j] = 0;
        }
    }
}
```

- 각 물높이의 안전 영역 개수를 구하고 나면은 기존 `vis[][]` 및 `safety` 값도 0으로 초기화

</details>
