### 1743번: 음식물 피하기

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1743)

**문제 조건**
- 통로의 세로길이 N 과 가로 길이 M, 그리고 통로에서 음식물 쓰레가가 존재하는 개수 K 입력한다.
- 그리고 다음 줄 부터 K개의 음식물 쓰레기에 대한 좌표 r,c를 입력된다.
- **쓰레기의 가로 세로가 붙어 있을 경우 하나의 쓰레기로 보며, 쓰레기가 통로에서 차지하는 칸당 크기가 된다.**

**출력**  
- 가장 큰 음식물 쓰레기의 크기를 출력한다.

### 풀이
> BFS, DFS 풀이 둘다 존재하며 DFS를 기준으로 해설을 하겠다.
1. `DFS`를 구현하여 주변에 쓰레기가 존재하면 재귀적으로 탐색하며 쓰레기의 칸인 `area` 값을 1씩 증가한다.
2. 가장 큰 음식물 쓰레기 크기를 저장하기 위해 `M`을 선언한 후에, `max()`를 이용하여 값을 갱신한다.
3. 통로의 모든 좌표를 돌면서 방문하지 않은 쓰레기 위치를 탐색하고 `M`의 최댓값을 구한다.
4. `M`을 출력한다.

### 핵심 코드

```
void DFS(int a, int b) {
    vis[a][b] = 1;
    area++;
    for(int i = 0; i < 4; i++) {
        int nx = a + dx[i];
        int ny = b + dy[i];
        if(nx < 0 || nx > n || ny < 0 || ny > m) continue;
        if(!street[nx][ny] || vis[nx][ny]) continue;
        DFS(nx, ny);
    }
}
```
- `DFS`를 구현하여 탐색하지 않은 쓰레기 칸을 찾을 때 `DFS`함수를 호출한다.
- `vis[][]`에 해당 칸을 방문표시를 하고, 쓰레기의 칸인 `area`를 1 증가시킨다.
- 탐색할 다음칸을 `nx, ny`에 지정하며 주변에 쓰레기인 칸이 있는지 확인하여, 존재하면 `DFS` 함수를 호출하여 재귀적으로 탐색한다.

```
int M = 0;
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        area = 0;
        if(street[i][j] && !vis[i][j]) {
            DFS(i, j);
        }
        M = max(M, area);
    }
}
```
- 음식물 쓰레기 칸의 넓이를 저장할 `M`을 선언한다.
- 통로의 모든 좌표를 탐색하며 쓰레기 칸이며, 방문하지 않은 곳일 경우 해당 칸의 `DFS`로 탐색한다.
- `max()` 함수를 통해 기존 최댓값과 탐색한 `area` 값의 최대값을 비교하여 저장한다.

