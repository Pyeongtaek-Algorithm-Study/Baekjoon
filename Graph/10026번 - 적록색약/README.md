### 10026번: 적록색약

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/10026)

**문제 조건**
- N x N 인 그림의 각 칸에는 R, G, B 중 하나의 색깔이 있다. 같은 색깔들의 인접한 부분을 구역으로 나눈다.
- 적록색약인 사람은 R, G을 구분하지 못하여 하나의 색깔로 인식한다.

**출력**  
- 적록색약이 아닌 사람과 적록색약인 사람이 그림을 봤을 때 각 색깔의 구역이 몇개 인지 출력한다.

### 풀이
1. RGB를 구분하여 BFS를 돌면서 구역을 탐색하도록 한다. 
    - 하나의 색깔(`it`)을 결정하여 N x N 구역을 `BFS`를 돈다.
    - 그 다음 색깔을 결정하여 똑같이 반복한다.
3. BFS를 하여 각 색깔별로 탐색하지 않은 곳을 탐색하며 이때 구역인 개수인 `nomal`을 증가시킨다.
4. 적록색약이 아닌 사람이 보는 구역의 개수를 구하고, 기존 그림에서 R인 칸을 G으로 변경한다.  _(R 를 G로 변경하여 그림에는 G, B만 존재하도록 변경)_
5. 아까 같이 각 색깔의 BFS를 돌면서 적록색약이 보는 구역이 `weak`를 증가시킨다.  _(코드 상으로 보면 R, G, B로 다 BFS를 돌지만 그림에는 R가 존재하지 않으므로 개수를 증가시키지 않는다.)_

### 핵심 코드
```
for(int i = 0; i < N; i++) {
    string str;
    cin >> str;
    strncpy(grid[i], str.c_str(), str.length());
}

for(int i = 0; i < N; i++) {
    for(int j = 0; j < N; j++) {
        for(auto it : color) {
            if(grid[i][j] == it && !visited[i][j]) {
                Q.push({i, j});
                bfs(it);
                nomal++;
            }
        }
    }
}

for(int i = 0; i < N; i++) {
    for(int j = 0; j < N; j++) {
        if(grid[i][j] == 'R') grid[i][j] = 'G';
        visited[i][j] = false;
    }
}
```
- 문자열을 입력받아 `strncpy` 를 통해 `char` 배열에 입력한다.
- `for(auto : color)` 반복문을 통해 각 색깔별로 `BFS`를 돈다.
- 찾고자 하는 색깔과 방문하지 않은 곳을 발견할 때마다 `BFS`를 돌고, `nomal`를 증가시킨다.
- 적록색약이 아닌 사람의 개수를 구하고 난 후 적록색약이 보는 그림으로 배열을 변경시키고, `visited` 배열을 초기화한다.
- 적록색약 버전의 그림을 `BFS`를 돌고 결과를 출력하도록 한다.
