### 1167번: 트리의 지름

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1167)
2. **도움 블로그** : https://velog.io/@ehdbs28/%EB%B0%B1%EC%A4%80-1167-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84

**문제 조건**
- 트리의 지름은 트리에서 임의의 두 노드 사이의 거리 중 가장 긴 것
- 정점의 개수 `V`, 그 다음 줄에 각 노드와 연결 된 노드 그리고 해당 간선의 길이를 번갈아 입력 -1을 입력받으면 해당 노드는 끝

**출력**  
- 입력 받은 노드와 간선을 파악하여 **가장 긴 트리의 지름**을 출력

### 풀이
1. 트리의 지름은 곧, 임의의 두 노드 사이의 간선의 합이 가장 긴 것을 의미한다.
2. **트리의 지름에 대한 이론 존재**
    1. 트리의 임의의 노드를 선택한 후에 가장 멀리 있는 노드를 찾기
    2. 찾은 노드에서 다시 가장 멀리 있는 노드를 찾기
    3. 1번에서 찾은 노드와 2번에서 찾은 노드가 트리의 지름이 되는 노드이다.
3. 위 이론을 이용하여 임의의 노드를 1번 노드로 선택하여 `DFS`를 이용하여 1번 노드에서 가장 멀리 있는 노드를 찾는다.
4. 찾은 노드에서 다시 한번 `DFS`를 이용하여 가장 멀리 있는 노드를 찾는다.
5. 4번 과정에서 가장 멀리 있는 노드를 구하는 과정에서 간선의 합을 구해서 최댓값을 갱신한다.
6. 결과적으로 찾은 최댓값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void dfs(int cur, int cnt) {
    vis[cur] = 1;
    if(dis < cnt) {
        dis = cnt;
        long_node = cur;
    }
    for(auto p : v[cur]) {
        if(vis[p.X]) continue;
        dfs(p.X, p.Y + cnt);
    }
}

void solve() {
    dfs(1, 0);
    
    fill(vis, vis + MAX, 0);
    dis = 0;

    dfs(long_node, 0);

    cout << dis << "\n";
}
```
- `dfs()`를 1번 노드로 시작하여, 각 노드를 방문 체크를 하고, 이전 간선들의 합과 다음 간선의 합을 비교하며 가장 멀리있는 노드 파악
- 가장 멀리 있는 노드를 찾으면 `long_node`에 저장
- `vis[]`을 다시 초기화하고, `dis`도 0으로 저장
- `long_node` 부터 `dfs()`를 탐색하면서 가장 멀리 있는 노드까지의 `dis` 값을 파악
- 결과적으로 `dis` 값에는 트리의 지름이 저장되므로 이를 출력
</details>

### 후기
- 트리의 지름 이론을 몰라서, 헤멘 문제
- 어찌보면 수학적인 이론을 활용한 `DFS`문제 같았다.