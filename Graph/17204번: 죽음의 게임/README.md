### 문제 제목
* * *
17204번: 죽음의 게임
### 링크
* * *
* <https://www.acmicpc.net/problem/17204>
### 문제 설명
* * *
사람들이 게임을 한다.
게임 방법은 사람들이 서로를 지목하고, 어떤 사람이 수를 말하면 지목한 순대로 숫자를 말하다가 그 수에<br>
걸린 사람이 술을 마시는 게임이다.
영기는 보성이가 걸리게 하고 싶어한다.
사람의 수와 보성이의 번호가 주어지고, 그 이후로 사람 순서대로 몇번을 지목했다가 입력이 된다.
보성이가 당첨되겠끔 영기가 말할 수 있는 최소한의 수를 구하면 된다.
### 구현 방법
* * *
이것도 최소한의 수를 구하는 것이므로 bfs문제이다.<br>
여기서 그래프를 만들때는 지목하는 사람과 지목을 당한 사람들끼리 서로 연결을 해줘야 한다.<br>
즉 1번 사람이 3번을 지목했다면 3번이 자식 노드가 되게끔 만드면 된다.<br>
애초에 입력을 받을때 0~n순으로 lst[0]~lst[n]은 지목당한 사람들이니 자식 노드들은 이렇게 구하면된다.<br>
큐에 0부터 넣고 큐에서 나온 popleft()한 수가 보성이의 번호가 나올때까지 반복문을 돌리면 되는데<br>
만약에 아니면, queue에 자식 노드의 자식 노드들을 추가하고, 방문할때마다 visit 딕셔너리에 연산 횟수와 <br>
노드의 번호를 추가해주면 된다.<br>
딕셔너리에 값을 추가할때는  v[lst[n]] = v[n] + 1 이렇게 간단히 추가해줄수 있다.
큐가 다 빌때까지 번호가 나와주지 않는다면 c=-1로 값을 정해주고 마지막에 if문에 c!=0이 아니면<br>
결국 안나온 것이므로, print(c)를 해주면 된다.

### 코드
* * *
<pre>
  <code>
from collections import deque
import sys

N, K = map(int, sys.stdin.readline().split())
lst = [int(input()) for i in range(N)]
q = deque([0])
c=0
v = {0: 1}
while q:
    n = q.popleft()
    if lst[n] == K:
        print(v[n])
        c=0
        break
    else:
        c=-1
    if lst[n] not in v:
        v[lst[n]] = v[n] + 1
        q.append(lst[n])
if c!=0:
    print(c)


  </code>
</pre>
