### 1967번: 트리의 지름

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1967)
2. **도움 블로그** : 

**문제 조건**
- 무방향 그래프인 트리
- 트리에서 임의의 두 노드를 선택하여 양쪽으로 당겼을 때, 가장 길게 늘어나는 경우가 존재
- 가장 길게 늘어나는 경우, 이를 원으로 그렸을 때 다른 노드들은 전부 원 안에 존재

**출력**  
- 루트가 존재하는 트리를 입력받고 노드 사이의 가중치 값을 입력 받았을 때, 이 때 **가장 길게 나올 수 있는 트리의 지름**을 구하기

### 풀이
1. 1167번과 매우 유사한 알고리즘 문제(https://www.acmicpc.net/problem/1167)
2. 입력 받을 때 무방향 그래프이기 때문에 **a -> b, b -> a로 가는 값을 vector에 둘 다 저장, c는 가중치를 의미**
3. 트리의 지름은 임의의 한 노드에서 출발하여 해당 노드를 기준으로 가장 멀리 있는 노드를 찾는다. 그리고 가장 멀리 있는 노드를 기준으로 멀리 있는 것을 구하면은 그것이 트리의 지름이 된다.
4. 루트노드인 1번 노드애서 출발하여 가장 멀리 있는 노드를 `long_node`에 저장
5. 다시 `vis[]`을 초기화하여 `long_node`에서 출발하여 가장 가중치가 멀리 있는 노드를 구하고 해당 사이 거리만큼을 `far`에 저장
6. 결과적으로, `far` 값에는 해당 트리로부터 나올 수 있는 최대의 트리의 지름의 값이 저장

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void dfs(int ariv, int dis) {
    vis[ariv] = 1;
    if(dis > far) {
        long_node = ariv;
        far = dis;
    }
    for(int i = 0; i < v[ariv].size(); i++) {
        if(!vis[v[ariv][i].first]) {
            dfs(v[ariv][i].first, v[ariv][i].second + dis);
        }
    }
}

void solve() {
    dfs(1, 0);
    far = 0;
    fill(vis, vis + n + 1, 0);
    dfs(long_node, 0);
    cout << far << "\n";
}
```
- `dfs()`로 1번 노드에서 출발하여 현재까지의 가중치 합인 `far`과 가장 멀리있는 노드를 저장하는 `long_node`값에 새로운 노드를 방문할 때마다 갱신
- `vis[]`에 다 방문하여 `long_node`값을 구하고 `vis[]`을 초기화한 후, `long_node`부터 출발하여 `far` 값을 지속적으로 갱신
- 모든 노드들에 방문을 하고 나면은 `far`값에는 트리의 지름이 저장
</details>

### 후기
- 초반에는 입력값의 방향으로만 `vector`에 넣어서, 루트노드에서 출발하여 `long_node`를 찾았지만, `long_node`에서 출발할 수 있는 노드가 없어서 양방향으로 넣었더니 해결