### 16724번: 피리 부는 사나이

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/16724)
2. **도움 블로그** : https://www.acmicpc.net/board/view/56507

**문제 조건**
- 성우가 피리를 불 때 영과일 회원들은 자기도 모르게 성우가 **젛해놓은 방향대로** 상하좌우로 움직임
- 이를 보던 재훈이는 회원들을 지키기 위해 특정 지점에 'SAFE ZONE'을 설치하여 성우의 피리를 **듣지 못하게** 하고자 함
- 지도의 행과 열로 $N$ X $M$ 크기이며 각 칸에는 성우가 정해놓은 방향이 있음
- 지도 밖으로 나가는 방향은 존재하지 않음

**출력**  
- 재훈이가 설치해야 할 'SAFE ZONE'의 **최소 개수**를 출력

### 풀이
1. 지도에서 방문하지 않은 곳부터 시작하여 해당 칸대로 움직임
2. `vis[][]`에 방문하는 칸마다 `ans` 값을 저장
3. _DFS_ 를 통해 다음 칸이 방문하지 않으면은 계속해서 탐색
4. 만일, 다음 칸이 이미 방문을 했고 `ans` 값과 같다면은 한바퀴를 이미 순회한 것이므로 `ans` 값을 1증가 시킴
5. 이후 현재칸의 값을 다음칸의 값으로 바꿈  
_다음칸 값을 바꾸는 이유는 만일 현재 칸의 값이 3이고 다음 칸의 값이 2라면은 2라는 곳에 **순회에 가능**한 것이므로 다음 칸 값으로 현재 값을 저장_
6. 위 과정을 `vis[][]`에 값을 다 넣을 때까지 반복하여 `ans` 값에 1을 뺀 값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void dfs(int x, int y) {
    vis[x][y] = ans;
    int nx = x;
    int ny = y;
    // show();
    if(board[x][y] == 'U') {
        nx -= 1;
    }
    else if(board[x][y] == 'D') {
        nx += 1;
    }
    else if(board[x][y] == 'L') {
        ny -= 1;
    }
    else if(board[x][y] == 'R'){
        ny += 1;
    }
    
    if(!vis[nx][ny]) {
        dfs(nx, ny);
    }
    else if(vis[nx][ny] == ans) {
        ans++;
    }
    vis[x][y] = vis[nx][ny];
}
```
- 현재 방문 칸에 `ans`값을 저장
- 현재 칸의 값에 따라 `nx`, `ny`의 값을 조절
- 만일, 다음 칸이 방문하지 않은 칸이면은 탐색을 진행
- 다음 칸이 방문했는데 만일 `ans` 값과 같다면은 해당 `ans` 값의 순회에 도달한 것이므로 `ans`를 1증가
- 현재 방문 값을 다음 방문 값으로 갱신
</details>

### 후기
- 다음 칸 값을 현재 값에 저장하는 것을 해야 이전 순회값에 도달했을 때 더 최소로 묶을 수 있었다.