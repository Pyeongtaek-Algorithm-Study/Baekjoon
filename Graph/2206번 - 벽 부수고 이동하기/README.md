### 2206번: 벽 부수고 이동하기

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2206)
2. **도움 블로그** : https://idkim97.github.io/2022-05-10-%EB%B0%B1%EC%A4%80_2206%EB%B2%88/

**문제 조건**
- N X M의 행렬로 표현되는 맵으로 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽을 나타냄
- (1, 1)에서 (N, M)의 위치까지 이동하려할 때 최단 경로로 이동하려 함. 이때 시작하는 칸과 끝나는 칸도 포함해서 셈
- 만약 이동 도중에 **한 개의 벽**을 부수고 이동하는 것이 더 짧은 경로가 있다면, 벽을 한 개 까지 부수고 이동할 수 있음
- 현재 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸

**출력**  
- 맵이 주어졌을 때, **최단 경로의 거리**를 출력하며, 불가능한 경우에는 -1을 출력

### 풀이
1. _BFS_ 로 길을 찾을 떄 두 가지의 경우가 있다. 벽을 뚫지 않고 했을 때의 경우, 벽을 한 개 뚫고 나서의 경우
2. 방문으로 (0, 0) 좌표에서부터의 거리를 기록할 `vis[][]`의 경우가 2개가 필요 -> `vis[2][][]` 를 선언
3. 기본적인 맵 안에 경로를 찾아서 갈 때 첫번쨰로 기본적인 해당 칸에 방문할 수 있고 벽 부수는 것을 사용하지 않은 경우에서 경로 탐색하여 `vis[0][][]`으로 탐색
4. 다음 경우로는 다음 칸에 벽이 있으며 벽 부수는 것을 사용하지 않은 경우를 `vis[1][][]`으로 탐색
5. 위 두가지 경우로 탐색하며 (N, M)의 위치에 도달할 때 해당 거리를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
int bfs() {
    queue<pair<pair<int, int>, int> > Q;
    Q.push({{0, 0}, 0});
    vis[0][0][0] = 1;
    
    while(!Q.empty()) {
        pair<pair<int, int>, int> cur = Q.front(); Q.pop();
        
        if(cur.X.X == n - 1 && cur.X.Y == m - 1) return vis[cur.Y][cur.X.X][cur.X.Y];
        
        for(int i = 0; i < 4; i++) {
            int nx = cur.X.X + dx[i];
            int ny = cur.X.Y + dy[i];
            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            if(map[nx][ny] == 0 && vis[cur.Y][nx][ny] == 0) {
                vis[cur.Y][nx][ny] = vis[cur.Y][cur.X.X][cur.X.Y] + 1;
                Q.push({{nx, ny}, cur.Y});
            }
            if(map[nx][ny] == 1 && cur.Y == 0) {
                vis[cur.Y + 1][nx][ny] = vis[cur.Y][cur.X.X][cur.X.Y] + 1;
                Q.push({{nx, ny}, cur.Y + 1});
            }
        }
    }
    
    return -1;
}
```
- `Q`를 선언하여 담은 값은 **<<좌표>, 벽 부수기의 유무>**을 나타냄
- 좌표 값이 `n - 1`, `m - 1`일 때의 해당 거리를 출력 _(문제는 (1, 1) -> (N, M)이지만 코드상으론 (0, 0) -> (N-1, M-1)이므로)_
- 탐색할 4방향을 `nx`, `ny`로 지정한 후에 맵 안인지 확인
- 탐색할 다음 칸이 0이고, 아직 탐색하지 않은 칸이면은 현재 거리 + 1 한 값으로 다음 방문 칸에 값을 저장후, `Q`에 추가
- 만일, 다음 칸이 1인 벽이고, 벽 부수기를 사용하지 않았으면 `vis[][][]` 값에 벽 사용 다음 방문에 현재 거리 + 1 한 값을 저장
- `Q`에 다음 칸과 벽 사용한 것을 추가
- 만일, 모든 탐색을 진행했지만, 도달해야 할 마지막 칸에 못했다면 -1을 반환
</details>

### 후기
- 완전 탐색으로 할 때인 벽을 1개씩 부수는 각각의 모든 경우에서 BFS 돌렸을 때 시간초과가 났었음
- vis를 3차원 배열로 벽을 부수는 유무를 하는 것으로 해야했었음