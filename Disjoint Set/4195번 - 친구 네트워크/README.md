### 4195번: 친구 네트워크

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/4195)
2. **도움 블로그** : https://down-develope.tistory.com/3

**문제 조건**
- 민혁이는 소셜 네트워크 사이트에서 친구를 만드는 것을 좋아하는 친구
- 어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 두 사람의 친구 네트워크에 몇 명이 있는지 구하기
- 친구 네트워크란, 친구 관계만으로 **이동**할 수 있는 사이

**출력**  
- 테스트 케이스에서 각 친구 관계가 생길 때마다, **두 사람의 친구 네트워크**에 몇 명이 있는지 출력

### 풀이
1. 보통 분리 집합에선 정수로 관계를 입력받지만, 이번 문제에선 문자열로 입력받음
2. 따라서, (`Fr`)친구 이름을 키 , 해당 위치값을 값으로 하는 선언
3. (`P_CNT`)친구를 나타내는 위치를 키와 친구의 명 수를 값으로 선언
4. A, B친구 관게를 입력받을 때 각각 처음보는 친구일 경우 추가저장 후, 친구 명 수를 1로 저장
5. 입력받은 A, B친구를 하나의 집합으로 구성 후에, A친구 명 수에 B 친구의 수를 합산
6. 합산한 **A 친구 명 수**를 관계마다 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void Union(int a, int b) {
    a = Find(a);
    b = Find(b);
    if(a != b) {
        parents[b] = a;
        p_cnt[a] += p_cnt[b];    
    }
}
```
- 입력받은 `a`, `b`의 친구 위치를 `a` 친구로 `parents`를 저장
- `a`의 친구 명 수인 `p_cnt[a]` 값에 `b`의 친구 명 수인 `p_cnt[b]`를 합산

```cpp
void solve() {
    int s = 0;
    
    for(pair<string, string> &p : con) {
        string a = p.first;
        string b = p.second;
        
        if(fr.count(a) == 0) {
            fr.insert({a, s});
            p_cnt.insert({s++, 1});
        }
        if(fr.count(b) == 0) {
            fr.insert({b, s});
            p_cnt.insert({s++, 1});
        }
        Union(fr[a], fr[b]);
        
        cout << p_cnt[Find(fr[a])] << '\n';
    }
}
```
- 친구의 위치를 가리킬 `s`를 선언
- 입력받은 친구 관계들인 `con`으로 각 `a`, `b` 친구를 저장
- 입력받은 친구들을 저장한 `fr`에 `a`, `b` 이름을 확인하여 없으면은 `fr`, `p_cnt`에 추가
- `p_cnt`에 저장할 때 처음 친구를 찾은 것이므로 친구 위치값을 키, 1명을 나타내는 값을 저장
- 선언한 `Union()`로 a, b 친구의 위치값을 매개변수로 전달하여 두 친구 관계를 하나로 묶음
- 저장된 `a` 친구의 **친구 관계 명수**를 출력
</details>

### 후기
- 블로그 방식보단 내 방식대로, 친구들의 value를 정수로 매겨서 진행(이 방식이 속도가 더 빨랐음.. 왜일까)