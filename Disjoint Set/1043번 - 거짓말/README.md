### 1043번: 거짓말

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1043)
2. **도움 블로그** : https://hsho.tistory.com/30

**문제 조건**
- 지민이는 파티에서 이야기를 하는 것을 좋아하는데, 이야기를 과장해서 얘기한다.
- 하지만 몇몇 사람들은 해당 이야기에 대한 진실을 알고 있기에, 과장된 이야기를 들으면 지민이를 거짓말쟁이로 인식할 수 있다.
- 따라서, 지민이는 파티에서 진실을 모르는 사람한테만 이야기를 하고자 한다.
- 다만, **어떤 사람이 파티에서 진실을 듣고, 또다른 파티에서 과장된 이야기를 들었을 때 지민이를 거짓말쟁이로 인식**할 수 있다.

**출력**  
- 지민이가 모든 파티에 참가하는데, 과장된 이야기를 할 수 있는 파티의 최댓값을 출력

### 풀이
1. 문제의 핵심은 파티에 진실을 아는사람이 있을 떄 해당 파티의 모든 인원은 진실을 안다. 또한, 추가로 진실을 알게된 인원이 또 다른 파티에 들어가면 해당 파티인원들도 진실을 알게 된다.
2. 파티를 하나의 집합으로 보면은 **Union-Find Algorithm**를 적용할 수 있다.
3. 각 파티에서 가장 먼저 사람을 기준으로 하여 나머지 인원을 `Union()`를 이용하여 집합을 생성한다.
4. 파티에서 이야기를 말할 수 있는 수를 `m`에 저장한 후, 파티를 파악하여 이야기를 못하면은 1씩 뺀다.
5. 각 파티의 기준인 사람을 진실을 알고 있는 집합의 각 원소의 `find()`를 통해 `parent`가 같으면은 해당 파티는 진실의 집합이다.
6. 이를 반복하여 지민이가 과장된 이야기를 할 수 있는 파트를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    for(int i = 0; i < m; i++) {
        for(int j = 1; j < party[i].size(); j++) {
            Union(party[i][0], party[i][j]);    
        }
    }
    
    int res = m;
    
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < t; j++) {
            if(Find(party[i][0]) == Find(truth[j])) {
                res--;
                break;
            }
        }
    }
    
    cout << res << "\n";
}
```
- 첫번째의 이중 반복문을 통해 각 파티의 첫번째 인덱스인원을 기준으로 `Union()`를 통해 하나의 집합으로 선언
- `res`값에는 파티의 개수를 저장
- 두번째 이중 반복문을 통해 각 파티에서 진실을 알고 있는 집합의 원소들을 비교한다.
- 조건문을 통해 해당 파티의 기준의 `parent`와 진실을 알고 있는 집합의 원소들의 `Find()`로 `parent`를 비교하여 서로 같으면은 해당 집합은 진실 그룹
- 진실 그룹이면은 이야기를 못하므로 `res--`한다.
- 최종적으로 각 파티를 비교하여 `res`를 출력하면은 지민이가 이야기할 수 있는 최대 파티 수 이다.
</details>

### 후기
- `Union`, `Find` 함수를 파스칼로 한 것은 이미 해당 명이 사전에 정의되어있어서 대체
- 각각의 집합들의 원소에서 공통된 부분이 있으면은 하나의 집합으로 합치고 해당 원소들의 최종 부모 값을 찾는 알고리즘 기법이었다.