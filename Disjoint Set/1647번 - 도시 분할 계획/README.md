### 1647번: 도시 분할 계획

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1647)
2. **도움 블로그** : 

**문제 조건**
- 마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어지며, 길은 어느 방향이로든 다닐 수 있음
- 각 길마다 길을 유지하는데 드는 유지비가 존재하며 임의의 두 집 사이에는 반드시 경로가 존재
- 마을의 이장은 현 마을이 커서 혼자 관리할 수가 없기 때문에 두 개의 마을로 분리하고자 함
- **마을의 분리 조건**
    - 각 분리된 마을에는 **하나 이상의 집**이 존재해야 함
    - 분리된 마을 내에서는 **임의의 두 집 사이에 경로가 존재**해야 하며 경로가 1개라도 있으면 이 집을 있는 다른 길은 없애도 됨
    - 분리된 마을 사이를 있는 길은 필요가 없으므로 없애도 됨
    - 위 조건을 만족하는 길들로 구성하고 유지비의 합이 최소가 되도록하고 싶음

**출력**  
- 분리된 마을에서 위 조건을 만족하는 **길의 유지비의 최솟값**을 출력

### 풀이
1. 첫번째로 마을의 길의 유지비를 최소로 만드는 방법은 **최소 스패닝 트리를 활용**하여 임의의 마을을 연결하는 길을 구할 수 있다.
2. 크루스칼 알고리즘을 활용하여 분리 집합으로 `n`개의 집을 하나의 마을로 일단 만든다.
3. 마을을 이제 분리해야 하는데 위 조건 중에 마을은 하나 이상의 집만 존재하면 된다.  
_즉, 크루스칼 알고리즘 이후에 마지막 연결 집만 끊어 놓으면 두 개의 마을이 생김_
4. 마을이 분리된 상태인 **마지막 길의 유지비만 제외**해서 더하면은 해당 마을의 최소 유지비가 된다.

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    sort(line.begin(), line.end());
    
    int node_cnt = 0;
    int ans = 0;
    
    vector<int> w;
    
    for(auto &it : line) {
        if(Find(it[1]) == Find(it[2])) continue;
        Union(it[1], it[2]);
        
        w.push_back(it[0]);
        
        if(++node_cnt == n - 1) break;
    }
    
    for(int i = 0; i < w.size() - 1; i++) {
        ans += w[i];
    }
    
    cout << ans << '\n';
}
```
- `line`에 유지비를 기준으로 오름차순으로 정렬
- `node_cnt`는 길의 개수와 `ans`는 분리된 마을의 유지비 값이다.
- `line`을 돌면서 각 집의 `parents`로 마을을 하나로 구성할 수 있도록 하며 크루스칼 알고리즘이므로 최소 유지비용으로 마을을 구성
- `w`값에는 추가한 길마다 유지비를 추가
- 최종적으로 길의 개수가 마을 개수 - 1 만큼 되었을 때 종료
- `w`값에 마지막 길을 제외한 것만 하면은 마지막 길이 끊어져서 마을이 2개로 분리된 것이고, 나머지 유지비만 `ans`값에 합산
- 최종적으로 `ans`를 출력하면 해당 마을 길의 유지비가 최소값
</details>

### 후기
- 문제를 처음 읽으면은 먼가 해석하기가 어려우며, 무언가 제대로 설명을 안해준 느낌을 받는 문제였다..
- 마을을 분리하는 것이 하나 이상의 집만 있으면 돼서 한 집은 무인도처럼 혼자 외롭겠네