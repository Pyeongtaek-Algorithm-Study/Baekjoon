### 1976번: 여행 가자

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1976)
2. **도움 블로그** : 

**문제 조건**
- 동혁이는 친구들과 함께 여행을 가려고 함.
- 도시가 `N`개가 있고 임의의 두 도시 사이에 길이 있을 수 있고, 없을 수도 있음.
- 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 파악

**출력**  
- 동혁이의 여행 계획에 속한 도시들이 순서대로 가능하면 **"YES"**, 불가능하면 **"NO"** 를 출력

### 풀이
_파이썬의 `Union-find` 풀이법으로 설명, Cpp는 `Dijkstra` 관점으로 푼거라 예외_
1. 도시가 `N`개가 존재할 때, 여행 일정의 도시가 모두 방문이 가능하다면, **해당 도시들을 하나의 집합**으로 볼 수 있다. 해당 집합 내에서는 어느 도시든 방문이 가능하기 때문
2. 각각의 도시의 가능 경로를 입력받을 때, 연결이 가능한 부분은 하나의 집합들로 합치면서 최종적인 집합을 구하는 방식
3. `i`번째 도시에서 방문가능한 도시들이 `N`개를 주어질 때, 이때 가능 경로인 `j`번째 도시와의 `union()`으로 집합의 여부를 파악
4. `parents[]` 의 각 인덱스 위치에 해당 부모의 집합 저장
5. `plan`에 각 여행 계획의 경로를 입력받아 `i`번째 도시에서 `i + 1`번째 도시로 이동함. 이때 **부모의 값이 서로 다르면은 해당 도시는 서로 다른 집합**이므로 `flag` 에 `False` 저장
6. `flag` 값이 `True`이면 "YES", `False`이면 "NO"를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```py
def solve():
    for i in range(1, n + 1):
        num = list(map(int, input().split()))
        for j in range(1, n + 1):
            if(num[j-1] == 1): 
                union(i, j)
    
    plan = list(map(int, input().split()))
    flag = True
    for i in range(len(plan) - 1):
        if(parents[plan[i]] != parents[plan[i + 1]]):
            flag = False
            break
    print("YES" if flag else "NO")
```
- 2중 `for`문에서 `range(1, n + 1)`한 이유는 도시의 가장 작은 수는 1부터 시작이여서 그렇다.
- `i`번째에서 `j`번째 도시와 가능 경로가 있으면 `union(i, j)`를 통해 부모 집합을 같게 설정
- `plan[]` 에 도시 여행 계획을 저장
- `plan[i]` 도시에서 `plan[i + 1]` 도시로 가는데 부모 집합이 같은지 파악하여 서로 다르면 아예 다른 집합이므로 도시 이동이 불가
- 이동이 불가하면 `flag` 값을 `False`로 저장
- 최종적으로 `flag`값이 `True`면은 도시 여행 계획은 하나의 집합이므로 "YES"를 출력, 아니면은 "NO"를 출력
</details>

### 후기
- Cpp 파일로는 `Union-Find` 풀이법이 아닌 `Dijkstra` 풀이법으로 풀었다. (어느 블로그에도, 없는 조금 과한 풀이법(?)이었다..)

_이렇게 푼 이유는 i번째 도시에서 i+1번째 도시로 이동이 가능하다면, Dijkstra 알고리즘으로 해당 번째 도시마다 돌려보면 가능 여부를 알 수 있지 않을까 해서 풀었다._

- 여행의 각 도시들이 이동 가능하다면 이를 하나의 묶음으로 생각할 수 있다는 것이 키 포인트인 것 같다.
