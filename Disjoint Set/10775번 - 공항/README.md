### 10775번: 공항

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/10775)
2. **도움 블로그** : https://barbera.tistory.com/23

**문제 조건**
- 공항에는 G개의 게이트가 있으며 각각 1번부터 G번까지의 번호를 가짐
- 공항에는 P개의 비행기가 순서대로 도착할 예정이며, i번째 비행기는 1번부터 $P_i$ 게이트중 사이에 하나에 영구적으로 도킹  
_즉, 비행기 값이 3일 떄, 1, 2, 3번 게이트 중 1개에 도킹이 가능하다는 것_
- 본 알고리즘 문제의 설명이 정확하게 설명을 안함. $g_i$가 아닌, **$P_i$** 로 설명을 하는 것이 더 적합하다고 생각이 됨
- 비행기가 도착할 떄 도킹할 게이트가 없다면 공항은 폐쇄를 하고, 이후 비행기들은 공항에 도착하질 못함

**출력**  
- 게이트와 비행기의 순서 예정이 주어졌을 때, 공항에 **비행기가 도킹할 수 있는 최대 수**를 출력

### 풀이
1. 해당 비행기의 도킹할 게이트를 나타낼 `parents`를 통해 _Union-Find_ 알고리즘 활용
2. 비행기가 도킹하고 나서 해당 **부모 값을 -1 한 값**에 저장
3. 2번 과정을 반복하다보면은 -1을 계속하므로 0이라는 게이트 값이 해당 비행기에 저장됨
4. 비행기가 도착할 떄 해당 게이트의 부모 값이 0이라면은 더이상 **하위 게이트들에 도착할 곳이 없다는 것**이므로 폐쇄
5. 최종적으로 여태동안 도킹한 비행기들의 개수를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int ans = 0;
    
    for(int i = 0; i < p; i++) {
        int dock = Find(airplane[i]);
        if(dock == 0) break;
        
        Union(dock - 1, dock);
        ans++;
    }
    
    cout << ans << '\n';
}
```
- `ans`는 도킹할 수 있는 비행기의 개수, `dock`은 공항에 도킹할 게이트를 나타냄
- 도킹할 게이트가 0이라는 것은 없다는 것이므로 공항이 폐쇄됨으로 `break`를 통해 정지
- 0이 아닌 게이트가 존재한다는 것은 해당 비행기가 **도킹할 게이트가 적어도 남았다**는 것
- 해당 비행기의 게이트를 부모 게이트의 -1 한 값에 저장
- 위 과정을 비행기 수에서 가능한 만큼 반복 후 `ans`를 최종 출력
</details>

### 후기
- 문제 풀이 자체는 간단하지만, 비행기가 게이트에 도킹한다는 내용의 설명이 좀 부족
- 다른 블로그들도 전부 문제 해석 자체가 어렸다는 걸로 봐선 해당 문제는 문제를 제대로 설명하지 않은 좋지 않은 문제 같음