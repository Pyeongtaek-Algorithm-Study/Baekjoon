### 16566번: 카드 게임

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/16566)
2. **도움 블로그** : https://pinacle.tistory.com/137

**문제 조건**
- 철수와 민수는 카드 게임을 진행하며 규칙이 존재(**흑과 백** 룰과 비슷)
	1. N개의 빨간색 카드로 1번부터 N번까지 번호가 있으며 이중 M개를 선택
	2. N개의 파란색 카드로 1번부터 N번까지 번호가 있으며 빨간색에서 고른 번호와 같은 파란색 카드 M개를 선택
	3. 철수는 빨간색 카드를, 민수는 파란색 카드를 가짐
	4. 철수와 민수는 고른 카드 중 1장을 뒤집어진 상태로 놓고, 다시 서로 뒤집어 큰 번호를 가진 사람이 승리
	5. 이 동작을 K번 해서 더 많이 이긴 사람이 최종적으로 승리
	6. 한번 낸 카드는 반드시 버려야함.
- 철수는 뛰어난 마술사로 본인이 낼 카드를 마음대로 조작이 가능(사용한 카드를 다시 들고 오거나 파란삭 카드가 없는 번호를 내기도 함)
- 민수는 뛰어난 심리학자로 철수가 낼 카드를 알아낼 수 있어서, 철수보다 **큰 번호 중에서 가장 작은 카드**를 내기로 함

**출력**  
- 민수가 승리하기 위해 민수가 각 차례에서 낼 **카드의 번호**를 출력
- 민수가 카드를 내지 못하는 케이스는 없음

### 풀이
1. 민수는 철수가 낼 카드를 알고 있기 떄문에 자신이 낼 카드를 이분 탐색으로 철수보다 큰 번호 카드를 제출
2. 민수는 자신의 카드를 사용했기에 제거해야 함. 이때 _Union-Find_ 알고리즘을 통해 다음으로 **큰 번호의 카드**로 묶음
3. 다음으로 큰 번호를 묶었기 때문에 이미 사용한 번호를 제출할려고 할 때 `Find()`을 통해 더 큰 번호 카드를 제출
4. 위 과정을 통해서 민수는 철수보다 큰 카드 번호들을 계속 제출함

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    sort(v.begin(), v.end());
	for(int i = 0, a; i < k; i++) {
		cin >> a;
		int idx = Find(upper_bound(v.begin(), v.end(), a) - v.begin());
		cout << v[idx] << '\n';
		Union(idx + 1, idx);
	}
}
```
- 민수의 카드인 `v`를 오름차순으로 정렬
- 철수의 카드인 `a`보다 큰 번호를 찾기 위해 `upper_bound()` 을 통해서 해당 번호보다 큰 카드의 위치를 찾음
- 해당 카드의 위치를 찾았으면 `Find()` 으로 해당 인덱스를 부모 인덱스를 찾음
- 최종적으로 찾은 인덱스를 통햐 `v[idx]` 를 출력하여 민수의 카드 번호를 출력
- 해당 `idx` 위치의 카드를 사용했으므로 **다음 칸의 카드를 사용**하도록 `Union()`을 통해 부모 값을 변경
- 위 과정을 철수가 낼 때마다 반복하여 민수는 카드를 제출
</details>

### 후기
- 계속 시간초과가 발생했던 문제
- `vector`의 `erase`를 사용하고 싶었지만 이는 안에 반복문이 또 존재하여 시간초과가 발생함으로 이를 _Union-Find_ 을 활용해 풀어야 하는 문제