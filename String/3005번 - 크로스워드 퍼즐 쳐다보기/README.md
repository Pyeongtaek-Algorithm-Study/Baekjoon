### 3005번: 크로스워드 퍼즐 쳐다보기

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/3005)
2. **도움 블로그** : 

**문제 조건**
- 크로스워드 퍼즐은 `R` X `C` 크기의 직사각형
- 퍼즐은 가로(왼쪽 -> 오른쪽), 세로(위 -> 아래)로 연속된 빈칸에 단어를 채움
- 동혁이는 이미 풀려있는 퍼즐은 확인한 후 연속된 단어들 중에서 사전 순으로 제일 앞서 있는 단어를 찾음

**출력**  
- 풀려있는 크로스워드 퍼즐이 주어졌을 때, **사전순으로 제일 앞서는 단어를 출력**

### 풀이
1. 직사각형의 크기인 `r`, `c`를 입력받고 한줄 마다는 문자열을 입력받으므로 `puzzle` 배열에 각 문자를 저장
2. 가로로 연속된 단어를 찾기
    1. #이 아닌 문자일 경우 `tmp` 문자열에 추가
    2. #일 경우 `tmp` 문자열의 길이가 2이상인 경우 `pq`에 추가
    3. 해당 줄에서 마지막 위치에 도달할 때 `tmp`에 저장된 문자열이 2이상일 경우 `pq`에 추가
3. 세로로 연속된 단어를 찾기
    1. 가로와 같은 로직이나, 세로방향으로 문자열을 하기 위해 `i`와 `j`의 위치를 반대로 설정
4. `pq`는 오름차순으로 설정되므로 가장 처음에 있는 것이 사전 순으로 제일 앞선 문자열이므로 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    string tmp;
    for(int i = 0; i < r; i++) {
        tmp = "";
        for(int j = 0; j < c; j++) {
            if(puzzle[i][j] != '#') tmp += puzzle[i][j];
            else {
                if(tmp.length() >= 2) pq.push(tmp);
                tmp = "";
            }
            if(j == c - 1 && tmp.length() >= 2) pq.push(tmp);
        }   
    }
    for(int i = 0; i < c; i++) {
        tmp = "";
        for(int j = 0; j < r; j++) {
            if(puzzle[j][i] != '#') tmp += puzzle[j][i];
            else {
                if(tmp.length() >= 2) pq.push(tmp);
                tmp = "";
            }
            if(j == r - 1 && tmp.length() >= 2) pq.push(tmp);
        }   
    }
    
    cout << pq.top() << '\n';
}
```
- 문자열을 저장할 `tmp` 선언
- 가로로 연속된 문자열을 찾기 위해 #이 아닌 위치일 경우 `tmp`에 추가로 문자 저장
- #의 문자열을 발견할 경우 길이를 확인하여 2이상인 경우 `pq`에 넣기
- `j`의 값이 해당 줄의 마지막 위치일 때 `tmp`의 저장된 문자열 길이를 체크하여 `pq`에 넣기
- 세로로 연속된 문자열을 찾기 위해 가로로 한 것과 같은 로직이나, `i`와 `j`를 반대로 하여 세로로 문자 찾아서 `pq`에 넣기
- `pq`는 오름차순으로 정렬되게 하여 문자열들이 사전 순으로 정렬되므로, 가장 처음에 있는 문자열 출력
</details>

### 후기
- 처음에 `if(j == r - 1 && tmp.length() >= 2)` 인 조건을 빼니 예제 문자열들이 없어서 당황했음
