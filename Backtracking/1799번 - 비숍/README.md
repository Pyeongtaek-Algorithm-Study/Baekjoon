### 1799번: 비숍

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1799)
2. **도움 블로그** : https://j2wooooo.tistory.com/80

**문제 조건**
- 체스에는 대각선 방향으로만 움직일 수 있는 비숍(Bishop)이 있음
- 따라서, 칸에 비숍이 있을 때 해당 대각선 방향에 있는 다른 말들을 잡을 수 있음
- 체스판에는 비숍을 놓을 수 없는 곳이 있으며, 체스판에 색칠된 부분이 놓을 수 없는 칸
- 비숍은 색칠된 부분에는 비숍을 놓을 수 없지만 지나갈 순 있음

**출력**  
- 체스판이 주어졌을 때, 비숍이 놓을 수 있는 칸에 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 **비숍의 최대 개수**를 출력

### 풀이
1. 체스판에는 2개의 색상이 존재하며 색깔끼리는 대각선으로 존재
2. 비숍의 경우 한 색상에 있으면 해당 색상에서 밖에 움직이지를 못함. 따라서, 비숍 말은 해당 색상에만 이동할 수 있으므로, **2개인 색상**으로 각각 나누어서 계산할 수 있음
3. 비숍이 한 칸에 존재할 때 잡을 수 있는 대각선인 칸의 행과 열들에서 일정한 수식 값이 존재
4. 좌상에서 우하로 가는 대각의 경우 **행+열의 값**이 같고, 우상에서 좌하로 가는 대각의 경우 **열-행의 값**이 같음
5. 각각의 대각으로 잡힐 수 있는 칸을 의미하는 배열을 선언
6. 해당 칸에 말을 놓을 수 있고, 대각의 배열에서 해당 칸에 잡히지 않는 다면 비숍을 놓을 수 있으므로, 대각의 배열의 값을 활성화
7. 만일, 해당 칸에 말을 놓을 수 없다면, 비숍의 갯수는 그대로 두고 다음 칸으로 이동
8. 이후, 해당 색깔의 다음 칸으로 이동하며 같은 과정을 진행
9. 다음 칸으로 이동하는 과정에서 열을 초과할 경우 다음 행으로 이동하며, 다음 행에는 열의 **지그재그**란 것을 주의
10. 계속 다음 칸으로 이동하면서, 체스판을 초과하는 행일 경우, 해당 **색상의 최댓값**을 갱신
11. 최종적으로 구한 각 색상의 최댓값의 합산을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```py
def tracking(row, col, cnt, color):
    if col >= n:
        row += 1
        if col % 2 == 0:
            col = 1
        else:
            col = 0
    
    if row >= n:
        ans[color] = max(ans[color], cnt)
        return
    
    if board[row][col] and not l[col - row + n - 1] and not r[row + col]:
        l[col - row + n - 1] = r[row + col] = 1
        tracking(row, col + 2, cnt + 1, color)
        l[col - row + n - 1] = r[row + col] = 0
    tracking(row, col + 2, cnt, color)
```
- `tracking()`에 행인 `row`, 열인 `col`, 비숍의 개수 `cnt`, 검은색 흰색을 나타내는 `color` 매개변수
- 열의 값이 체스판의 크기를 넘어설 경우 다음 행으로 이동한 후, 색상은 **지그재그**이므로 다음 열을 2로 나누어 값을 진행
- 만일 행의 값이 체스판의 크기를 넘어설 경우 더 이상 놓을 칸이 없는 것이므로, 해당 비숍의 갯수와 해당 색상의 비숍 개수를 비교하여 최댓값 갱신
- 해당 행과 열 칸에 말을 놓을 수 있고, 우상에서 좌하로 내려가는 대각선을 가리키는 `l[]`과 좌상에서 우하로 내려가는 대각선을 `r[]`에서 해당 칸에 잡히지 않으면은 비숍을 놓음
- `l[]`에서 `col - row`를 할 때 **음수**가 나올 수 있으므로, `n - 1`을 더해서 음수를 상쇄시켜 0부터 시작할 수 있도록 함
- `l[]`와 `r[]`에서 해당 잡을 수 있는 칸을 나타내는 위치에 1로 저장
- 해당 색상의 다음 칸인 `col + 2`로 탐색 진행
- _Backtracking_ 으로 해당 잡을 수 있는 칸을 다시 회수함
- 만일, 해당 칸에 놓을 수 없거나, 잡히는 칸일 경우에, 다음 칸으로도 계속 탐색해야 함으로 `cnt`는 그대로 두고 다음 칸 탐색

```py
def solve():
    tracking(0, 0, 0, 0)
    tracking(0, 1, 0, 1)
    
    print(ans[0] + ans[1])
```
- (0, 0)또는 (0, 1) 좌표에서 시작한 후, 말의 개수는 0, 색상은 0과 1로 구분
- 색상을은 검은색과 흰색 2개가 존재하고, 각각의 시작위치는 1칸씩 다름
- 비숍은 해당 색상에서만 움직일 수 있음으로 2개로 구분해서 진행
- 최종적으로 각각의 색상에서 놓을 수 있는 최대 개수인 `ans[0]` 과 `ans[1]` 값의 합산을 출력
</details>

### 후기
- PS의 과정이 매우 신기했음. 이는 코드보다 풀이를 생각하는 것이 어려운 문제