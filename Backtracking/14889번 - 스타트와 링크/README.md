### 14889번: 스타트와 링크

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/14889)
2. **도움 블로그** : 

**문제 조건**
- 축구를 하기 위해 N명이 있고, N/2명으로 이루어진 스타트 팀과 링크 팀으로 나눔
- $S_{ij}$는 i번 사람과 j번 사람이 같은 팀에 속해있을 때, 팀에 더해지는 능력치, **팀의 능력치는 팀에 속한 모든 쌍의 능력치 $S_{ij}$의 합**  
_팀에 더해지는 능력치는 $S_{ij}$와 $S_{ji}$도 함께 더해야 한다_
- 축구를 재미있게 하기 위해서 스타트 팀과 링크 팀의 능력치의 차이를 최소로 하려고 함.

**출력**  
- 스타트 팀과 링크 팀의 **능력치의 차이의 최솟값**을 출력

### 풀이
1. 각 `i`, `j` 위치일 때의 능력치를 `soccer[][]`에 저장
2. `back()`를 통해서 백트래킹 알고리즘을 구현
3. `for`반복문에서 `vis[]`에 해당 `cur + 1` 번째 사람을 `true`로 설정  
4. `vis[]`에서 `true` 팀을 스타트 팀, `false` 팀을 링크 팀으로 구분
5. `l`은 현재 `true` 팀의 인원으로 `n / 2` 명이 되었을 때 팀을 구분
6. `pt1`, `pt2` 값은 각각 스타트, 링크 팀의 능력치 값으로 `i`, `j` 번째가 모두 `true`이면 스타트 팀의 능력치 요소이므로 합하고, `false`이면 링크 팀의 능력치 요소이므로 합함
7. 최종적인 `pt1`, `pt2` 값을 구한 후 서로의 절댓값 차이로 `ans` 값과 비교하여 더 최소인 값을 `ans`에 갱신
8. 다시 돌아가서 `vis[]`를 `false`로 바꿔서 모든 경우의 수를 백트래킹으로 조사
9. 최종적인 `ans`에는 모든 경우의 수에서 나올 수 있는 각 팀의 능력치 최솟값의 차이가 저장됌으로 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void back(int cur, int l) {
    if(l == n / 2) {
        int pt1 = 0, pt2 = 0;

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(vis[i] == true && vis[j] == true) pt1 += soccer[i][j];
                if(vis[i] == false && vis[j] == false) pt2 += soccer[i][j];
            }
        }
        
        ans = min(ans, abs(pt1 - pt2));
        return;
    }

    for(int i = cur + 1; i < n; i++) {
        vis[i] = true;
        back(i, l + 1);
        vis[i] = false;
    }
}
```
- 코드 설명
</details>

### 후기
- 2명일 떄의 쌍을 구하는 것은 쉽게 알 수 있었지만, 그 이상일 때는 어떻게 쌍을 구해야 하는지 어려웠음
- 백트래킹을 어떻게 구현해야 하는지가 관건으로 난이도 자체는 낮을 수 있지만 아이디어 구현은 어려웠음