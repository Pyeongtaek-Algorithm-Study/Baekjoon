### 1987번 : 알파벳

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1987)


**문제 조건**
- 세로 R칸, 가로 C칸으로 된 보드, 각 칸에는 대문자 알파벳이 적혀있으며 좌측 상단(1행 1열) 에는 말이 있다.
- 말은 상하좌우로 한 칸 이동 할 수 있으며, 이동할 칸에는 여태동안 지나온 칸에 적혀 있는 알파벳과 중복이 되선 안된다.  
_말이 지나온 길에 **같은 알파벳이 두 번이상 불가**_


**출력**  
- 말이 보드에서 지나갈 수 있는 최대 칸 수를 출력  
_( ※ 말이 시작하는 칸도 포함하여 1칸부터 시작 )_

### 풀이
1. 말을 움직이다가 다음에 칸에 갈 수 없을 때 다시 되돌아가서 움직이므로 전형적 **백트래킹** 문제
2. 지나온 칸의 알파벳을 기억하기 위해 `bool alpha[26]` 을 선언
3. `board[0][0]`의 알파벳 값을 `alpha[]`에서 `true`로 활성화하기 위해 _'A'_ 를 뺀 값에 `true`로 설정
4. `DFS()`로 **재귀적으로 탐색하며 백트래킹**을 구현
5. 보드를 탐색할 때 마다 `ans` 값에 `cnt`와 최대값을 비교하여 저장
6. 탐색 가능한 칸을 조건문을 통해 구현하고, 가능하면 `DFS()`를 호출
7. 탐색하다가 더이상 갈 수 없을 때에는 되돌아가야하므로 **`true`로 했던 알파벳을 다시 `false`로 저장**
8. 갈 수 있는 모든 칸을 간 이후에 `ans`에는 탐색할 수 있는 최대 칸 수가 저장됨. 


### 핵심 코드

```
void dfs(int x, int y, int cnt) {
    ans = max(ans, cnt);
    for(int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx < 0 || nx >= r || ny < 0 || ny >= c) continue;
        if( alpha[board[nx][ny] - 'A']) continue;
        alpha[board[nx][ny] - 'A'] = true;
        dfs(nx, ny, cnt + 1);
        alpha[board[nx][ny]-'A'] = false;
    }
}

```
- `ans`와 `cnt`를 비교하여 최대값을 저장
- `nx`, `ny`에 탐색할 다음칸을 저장한 후 탐색 가능한지 살펴봄.
- 탐색 가능할 경우 다음칸 알파벳을 `true`로 저장한 후 `dfs()` 호출
- 더이상 탐색이 불가한 경우, 되돌아가므로 `true`로 저장했던 알파벳을 다시 `false`로 저장
