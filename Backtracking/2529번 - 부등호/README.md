### 2529번: 부등호

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2529)
2. **도움 블로그** : 

**문제 조건**
- 부등호 기호 '<' 와 '>'가 k개 나열된 순서열 A가 존재
- 나열된 부등호 기호 앞 뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족
- 나열된 부등호 관계를 만족하는 정수가 하나 이상 존재하며, k+1자리의 정수 중 최댓값과 최솟값이 존재
- 부등호 사이에 들어갈 숫자는 0 ~ 9 사이의 수 중 1개이며 각 자리마다 숫자들이 달라야 함

**출력**  
- 제시된 부등호 관계를 만족하는 **k+1 자리의 최대, 최소 정수**를 각각 출력하며 첫 자리가 0인 경우도 포함되어야 함

### 풀이
1. 정수의 시작점은 0 ~ 9까지로 시작할 수 있으며 시작 숫자를 설정하고 재귀적으로 탐색
2. 사용한 정수를 확인하기 위한 `chk[10]`를 선언하고, 재귀적으로 탐색하며 사용한 정수들을 체크
3. 정수의 길이가 k + 1이 되었을 때 해당 정수의 최대, 최소 정수를 비교하여 갱신
4. 재귀적으로 탐색할 떄 사용한 정수일 경우는 건너뛰고 **사용하지 않은 정수**로 해당 부등호를 파악하여 알맞은 정수를 이어나감
5. 모든 경우를 파악해야 하므로 백트래킹방식을 통해서 사용한 정수를 다시 **해제한 후 해당 정수도 다시 원상복귀** 식으로 반복
6. 최종적으로 완성된 최대, 최소 정수값 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void recursive(string num, int arr[10]) {
    int len = num.length() - 1;
    if(len >= n) {
        min_ans = min(min_ans, num);
        max_ans = max(max_ans, num);
        return;
    }
    
    for(int i = 0; i < 10; i++) {
        if(arr[i]) continue;
        
        if((k[len] == '>' && num[len] - '0' > i) || (k[len] == '<' && num[len] - '0' < i)) {
            num += to_string(i);
            arr[i] = 1;
            recursive(num, arr);
            arr[i] = 0;
            num = num.substr(0, num.length() - 1);
        }
    }
}
```
- `len`은 `num` 문자열의 길이 용도 (0부터 카운트하므로 -1을 함)
- 만일, `len`이 언급한 `k` 개의 부등호 개수와 같으면 식이 완성된 것이므로 최댓, 최소 정수를 비교하여 갱신
- 아직 부등호에 알맞는 정수 길이가 되지 않으면은 해당 위치에 알맞은 숫자를 찾아서 **재귀적**으로 탐색
- `arr[]`은 사용한 정수를 확인하는 용도
- 해당 칸의 부등호가 '>' 면은 해당 정수는 앞 선 정수 보다 작은 값을 `num`에 붙이고 해당 숫자 사용에 체크
- 해당 칸의 부등호가 '<' 면은 해당 정수는 앞 선 정수 보다 큰 값을 `num`에 붙이고 해당 숫자 사용에 체크
- 백트래킹으로 되돌아와 사용한 숫자를 해제하고 `num`에 붙였던 정수를 다시 빼서 원상복귀

</details>

### 후기
- 