### 16235번: 나무 재테크

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/16235)
2. **도움 블로그** : https://smartshk.tistory.com/49

**문제 조건**
- 로봇 S2D2는 땅의 각 칸을 양분을 조사하니 처음은 5만큼 들어있음
- **나무 재태크의 과정**
    - 봄
        - 나무의 나이가 어린 나무부터 자신의 나이만큼 땅의 양분을 먹음
        - 만약, 땅의 양분이 충분하지 않아 자신의 나이만큼 먹지 못할 경우 해당 나무는 바로 죽음
    - 여름
        - 죽은 나무의 나이의 절반만큼이 해당 땅의 양분이 증가(소수점 제외)
    - 가을
        - 나무가 번식하는 시기로 나무의 나이가 5배수일 때 자기 인접한 주변 8칸에 나이가 1인 아기 나무가 생성
        - 땅을 벗어나는 칸에는 나무 생성이 되지 않음
    - 겨울
        - 로봇 S2D2가 땅을 돌아다니면서 각 칸에 양분을 추가
        - 양분의 양은 입력받은 각 칸의 수만큼 추가
- 처음 입력 값에 나무의 나이를 **오름차순**으로 입력 받음

**출력**  
- K년이 지난 후 땅에 살아있는 **전체 나무의 개수**를 출력

### 풀이
1. 문제의 로직은 어렵지 않으나, 시간 제한이 많이 힘든 문제로 추가, 제거가 `O(1)`인 연산이 필요
2. 따라서, 나무의 추가, 제거를 `deque()`를 이용하여 시간 내에 푸는 것
3. 처음 입력받은 나무들이 나이를 기준으로 오름차순으로 정렬되서 입력 받음
4. 봄에는 해당 칸에 나무가 있을 시 차례대로 양분을 줘서 나이를 1씩 증가시키다가, 양분을 못 주는 **나무의 위치**를 기억
5. 여름에는 마지막 나무부터 양분을 못 주는 나무까지 차례대로 내림차순으로 나이의 절반만큼 양분을 추가하고 **마지막 나무 순서**들을 제거시킴
6. 가을에는 해당 칸의 나무의 나이가 5배수인 것이 있으면 인접한 8칸의 나무에 땅 내부에 번식할 수 있는 곳에 나이가 1인 나무를 **가장 앞쪽**에 추가  
_앞쪽에 추가함으로써 정렬 연산이 필요 없음_
7. 겨울에는 각 칸에 입력받은 양분의 크기만큼씩 추가
8. 위 과정을 K년 만큼 반복시켜서 각 칸에 **살아남은 나무들의 개수**를 합하여 전체 나무 수를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void spring_summer() {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            int idx = 0, last_cnt = tree[i][j].size();
            for(; idx < last_cnt; idx++) {
                if(tree[i][j][idx] <= ground[i][j]) {
                    ground[i][j] -= tree[i][j][idx];
                    tree[i][j][idx]++;
                }
                else break;
            }
            
            while(last_cnt-- > idx) {
                ground[i][j] += (tree[i][j][last_cnt] / 2);
                tree[i][j].pop_back();
            }
        }
    }
}
```
- 각 칸에 시작 위치인 `idx`, 해당 칸의 나무의 개수인 `last_cnt`
- 현재 나무의 나이인 `tree[i][j][idx]` 가 해당 칸의 양분보다 작거나 같으면 땅의 양분을 주고 나이를 증가
- 해당 번째의 나이가 땅의 양분 이상으로 많을 때 해당 번째를 `idx`가 저장됨
- 여름으로 마지막 나무부터 위에서 idx번째의 나이까지 양분을 어차피 못주는 것임으로 `ground[][]`에 나이의 절반만큼을 땅의 양분으로 줌
- 마지막 순서의 나무 제거를 반복

```cpp
void autumn_winter() {
    int dx[8] = {0, 1, 0, -1, 1, 1, -1, -1};
    int dy[8] = {1, 0, -1, 0, -1, 1, -1, 1};
    
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            for(int idx = 0; idx < tree[i][j].size(); idx++) {
                if(tree[i][j][idx] % 5 == 0) {
                    for(int d = 0; d < 8; d++) {
                        int nx = i + dx[d];
                        int ny = j + dy[d];
                        
                        if(nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
                        
                        tree[nx][ny].push_front(1);
                    }
                }
            }
            
            ground[i][j] += soil[i][j];
        }
    }
}
```
- 가을에는 해당 칸의 나무의 나이가 5배수인 것이 있으면은 인접한 8번째 칸을 `nx`, `ny`에 저장
- 생성할 나무의 위치가 땅의 내부이면은 인접한 칸에 나이가 1인 나무를 **맨앞 순서**에 추가, 맨앞에 추가함으로써 *기존의 오름차순으로 정렬된 것*에 그대로 이어짐
- 겨울으로 각 칸에 `soil[][]`만큼 각 `ground[][]`에 양분을 추가
</details>

### 후기
- `priority_queue`를 사용하면 안됬었다. **O(1)**의 연산들을 해야했다. 큐에 값을 넣으면 정렬이 **O(log N)** 시간 만큼이 발생된다고 함
- 정렬이 필요 없는 이유가 `deque`를 쓰면됐으며, 처음 나무를 줄 때 **오름차순**으로 주는 듯함