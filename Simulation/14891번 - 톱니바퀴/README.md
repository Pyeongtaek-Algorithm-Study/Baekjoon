### 14891번: 톱니바퀴

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/14891)  
참고 블로그 : [참고했던 블로그](https://starlightbox.tistory.com/63)

**문제 조건**
- 총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 일렬로 정렬
- 각 톱니에는 N극 또는 S극 중 한개를 가지며, 톱니바퀴는 왼쪽부터 1번으로 4번까지 존재
- 4개 중에 한 개의 톱니바퀴를 선택하고 방향을 선택(1은 시계 방향, -1은 반시계 방향)
- 톱니바퀴가 맞닿은 극이 서로 다른 극일 경우, 선택한 톱니바퀴 방향에 따라 맞닿은 톱니바퀴는 반대 방향으로 회전  
![톱니바퀴](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14891/4.png)

**출력**  
> K번 회전시킨 이후의 4개의 톱니바퀴의 가장 상단의 톱니의 점수 합을 출력(S극일 때 `2^(톱니번호-1)`)
- 1번 톱니가 S극이면 **1**점
- 2번 톱니가 S극이면 **2**점
- 3번 톱니가 S극이면 **4**점
- 4번 톱니가 S극이면 **8**점

### 풀이
1. 톱니바퀴의 형태를 `string`형태 `gear[6]` 선언 후에 `1~4` 인덱스에 입력  
_인전합 톱니를 살필 때 첫번째 그리고 네번째 톱니와 맞불리는 경우를 위함._
2. `rotation()`에 톱니바퀴 번호와 방향을 입력받고, `vis[]`에 방문표시를 함.
3. 방향이 시계방향일 경우 `gear[idx]` 를 한칸씩 뒤로 밀고, 반시계 방향일 경우 한칸씩 당김.
4. **해당바퀴가 회전했으므로 기존 2번쨰 톱니와 6번째 톱니를 회전방향을 생각하여 인전한 톱니와 극이 다른지 생각**
5. 극이 서로 다를 경우 인접한 톱니바퀴에 `rotation()` 재귀적으로 진행
6. 더이상 방문할 수 있는 톱니가 없으면은 모든 회전을 마친 것이므로, 톱니바퀴의 번호에 따라 `pow()` 를 이용하여 점수합산 계산

### 핵심 코드
<details>
<summary>코드 보기</summary>

```
void rotation(int idx, int d) {
    if(idx < 1 || idx > 4) return;
    if(vis[idx]) return;
    
    vis[idx] = true;

    if(d > 0) {
        gear[idx] = gear[idx][7] + gear[idx].substr(0, 7);
        // lefe gear
        if(gear[idx][7] != gear[idx - 1][2]) // 6 -> 7
            rotation(idx - 1, -d);
        // right gear
        if(gear[idx][3] != gear[idx + 1][6]) // 2 -> 3
            rotation(idx + 1, -d);
    }
    else {
        gear[idx] = gear[idx].substr(1, 7) + gear[idx][0];
        // lefe gear
        if(gear[idx][5] != gear[idx - 1][2]) // 6 -> 5
            rotation(idx - 1, -d);
        // right gear
        if(gear[idx][1] != gear[idx + 1][6]) // 2 -> 1
            rotation(idx + 1, -d);
    }
}
```
- 톱니바퀴 번호가 1보다 작거나, 4보다 큰 경우 또는 이미 방문한 톱니바퀴일 경우 제외
- 방향이 시계방향일 경우 해당 톱니바퀴의 배열을 한칸씩 뒤로 밀고, 반시계일 경우 한칸씩 당김.
- 시계방향일 경우 왼쪽 톱니바퀴인 경우 톱니 **6**번이 **7**번으로 바뀌었으므로 **7**번 톱니와 왼쪽 톱니바퀴의 **2**번째 톱니와 비교  
오른쪽 톱니바퀴인 경우 톱니 **2**번이 **3**번으로 바뀌었으므로 오른쪽 톱니바퀴의 **6**번과 비교
- 반시계방향일 경우 일때도 마찬가지로 회전한 경우를 따져서 톱니끼리 계산
- 서로 톱니가 다르다면 옆 톱니도 회전해야 하므로 `rotation(인접 톱니바퀴, 반대방향)` 을 호출

</details>