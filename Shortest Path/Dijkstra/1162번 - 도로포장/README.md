### 1162번: 도로포장

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1162)
2. **도움 블로그** : https://conkjh032.tistory.com/397

**문제 조건**
- 준영이는 매일 서울에서 포천까지 출퇴근을 하지만 잠이 많은 준영이는 늦잠을 자 포천에 늦게 도착하기 일쑤
- 돈이 많은 준영이는 고민 끝에 K개의 도로를 포장하여 서울에서 포천까지 가는 시간을 **단축**하고자 함
- 도시 사이를 잇는 임의의 도로를 포장하여 해당 도로의 걸리는 시간을 0으로 하여 서울에서 포천까지 **최소 시간**이 걸리도록 K개 이하의 도로를 포장
- 포장할 수 있는 도로는 이미 있는 도로에만 포장할 수 있으며, 해당 도로의 걸리는 시간은 0으로 변경
- 편의상 1번 도시를 서울이라 하고, 포천을 N번 도시라 할 때 항상 1 -> N으로 **갈 수 있는 데이터**를 제공

**출력**  
- K개 이하의 도로를 포장하여 얻을 수 있는 최소 시간을 출력

### 풀이
1. `k`개 이하의 도로를 포장했을 때의 각 도시에 도달할 수 있는 최소 거리를 저장할 `dp[][]`을 선언
2. _Priority Queue_ 인 `pq`를 선언할 때, 포장한 도로의 개수인 `cnt`도 저장할 매개 변수도 포함
3. 일반적인 _Dijkstra_ 알고리즘과 동일하게 진행
4. 현재 노드에서 다음 노드로의 최소 거리를 찾을 떄 할 수 있는 경우의 수는 **2개**
5. 첫번째, 기존 알고리즘인 다음 노드 거리까지의 거리가 기존 기록보다 짧다면 기록을 갱신후 `pq`에 추가
6. 두번째, 다음 노드 거리를 할 때 만일 현재 도로를 포장 상태로 해서, 현 노드 거리를 포장 도로 개수를 1 증가시킨 다음 노드 거리보다 짧다면 기록을 갱신후 `pq`에 추가
7. 단, 도로 포장을 추가할 떄 `k`개 이하인지 체크
8. 위 과정을 거치면 `dp[][]`에는 포장 도로 개수에 따른 각 도시의 최소 거리가 저장
9. 포장 도로가 `k`개 이하일 때의 `n` 도시의 거리를 비교하여 최솟값 찾은 후, 출력  
_k개의 임의의 도로를 전부 포장했다고 항상 n번 도시의 거리가 최솟값이 아닐 수도 있어서 k개 이하인 경우들을 다 비교해야 함_

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
ll dijkstra() {
    fill_n(&dp[0][0], 21 * 10001, INF);
    priority_queue<pair<pair<ll, int>, int> > pq;
    pq.push({{0, 1}, 0});
    dp[0][1] = 0;

    while (!pq.empty()) {
        ll cost = -pq.top().X.X;
        int node = pq.top().X.Y;
        int cnt = pq.top().Y;
        pq.pop();
        
        if (dp[cnt][node] < cost) continue;

        for (auto &edge : edges[node]) {
            int nxt_node = edge.X;
            ll nxt_cost = cost + edge.Y;

            if (dp[cnt][nxt_node] > nxt_cost) {
                dp[cnt][nxt_node] = nxt_cost;
                pq.push({{-nxt_cost, nxt_node}, cnt});
            }

            if (dp[cnt + 1][nxt_node] > cost && cnt + 1 <= k) {
                dp[cnt + 1][nxt_node] = cost;
                pq.push({{-cost, nxt_node}, cnt + 1});
            }
        }
    }

    ll ans = INF;
    for (int i = 0; i <= k; i++) ans = min(ans, dp[i][n]);
    return ans;
}
```
- 최악의 케이스에 도로의 걸리는 시간이 `int` 타입을 넘을 수 있으므로 `long long` 타입으로 저장
- 초기 dp[][]에 매우 큰 수인 `INF`값을 모든 위치에 저장
- _Priority Queue_ 타입으로 `pq`를 선언 후, _{{거리, 도시}, 포장 도로 개수}_ 의 값을 저장받음
- 처음 값으로 1번 도시에서 시작해서 거리가 0이고, 포장 도로 개수도 0인 값을 추가
- 시작위치에 거리 0 저장
- 일반적인 _Dijkstra_ 알고리즘 구조와 같으므로 핵심 로직을 제외한 설명은 생략
- 현재 `cnt`가 `k`개 미만으로 현재 도시에서 다음 도시로 가는 도로의 시간을 0으로 했을 때(즉, 포장 도로로 만들 때) 시간이 더 단축되면은 해당 상태를 기록 후, `pq`에 추가
- 위 과정을 거치고 나면 `dp[][]`에는 `0`부터 `k`개 이하일 때의 각 **도시로 가는 최소 거리**가 저장
- `dp[][]`에 `k`개 이하일 때의 각 `n` 도시로 가는 최소 거리를 비교하여 최솟값을 찾아 `ans`에 저장 후, 반환
</details>

### 후기
- python의 if문에 and을 할 때 순서를 조심해야 겠음. python에서 리스트를 참조하는 조건문일 때 해당 범위 내인지는 먼저 확인해야 했음
- 왜 DP일까를 생각했어야 하는 문제였음