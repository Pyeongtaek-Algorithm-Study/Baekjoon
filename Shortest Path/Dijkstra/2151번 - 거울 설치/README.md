### 2151번: 거울 설치

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2151)
2. **도움 블로그** : https://hibee.tistory.com/175

**문제 조건**
- 채영이는 거울을 들여다보는 것을 좋아하여 집 곳곳에 거울을 설치해두고 집 안을 돌아다닐 때 마다 거울을 봄
- 채영이는 새 해를 맞이하여 이사를 하게 되었는데, 새 집에도 거울을 매달만한 위치가 여러 곳 존재
- 채영이네 새 집에는 문이 두 개 있으며, 거울을 잘 설치하여 **한 쪽 문에서 다른 쪽 문을 볼 수 있도록 거울을 설치**하는 장난을 칠려고 함.
- 거울을 설치할 때에는 **45도 기울어진 대각선 방향**으로 설치하며, 거울은 양면 거울이므로 양 쪽 모두 반사가 가능
- 채영이는 거울을 매우 많이 가지고 있어 부족한 경우는 없음
- 거울을 어떻게 설치해도 한 쪽 문에서 다른쪽 문을 볼 수 없는 경우는 주어지지 않음

**출력**  
- 한쪽 문에서 다른 쪽 문을 볼 수 있도록 설치해야 하는 **거울의 최소 개수**를 출력

### 풀이
1. 집의 각 칸마다 4개의 방향의 거울의 개수를 통해 도달할 수 있는 위치들을 기억할 `vis[][][]` 선언
2. 한쪽 문에서 탐색할 수 있는 4개의 방향을 _거울 개수를 기준으로 하는 우선순위 큐_ 에 담아서 시작위치와 방향을 넣음
3. 큐에서 꺼내 해당 방향에 다음 칸을 확인
4. 갈 수 있을 때 벽이 아닌 경우 해당 방향 그대로 큐에 넣기
5. 갈 수 있을 때 거울을 설치 가능한 경우 **2가지**를 큐에 넣기
    1. 거울을 대각선으로 설치하여 방향이 **좌측**으로 90도 꺾여서 진행
    2. 거울을 대각선으로 설치하여 방향이 **우측**으로 90도 꺾여서 진행
6. `vis[][][]`에 해당 거울의 개수가 **해당 칸의 방향 값에서 더 작을 때** 값을 갱신할 수 있는 것이므로 해당 거울 수로 저장
7. 해당 칸이 다른 쪽 문에 도달했을 때 **해당 거울의 개수**를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```py
def solve():
    # 각 칸마다 4방향의 거울 개수 기록
    vis = [[[INF] * 4 for _ in range(n)] for _ in range(n)]
    hq = []
    for i in range(4):
        heapq.heappush(hq, (0, door[0], i))
    
    dx = [0, -1, 0, 1]
    dy = [-1, 0, 1, 0]
    
    while hq:
        cnt, (coor_x, coor_y), d = heapq.heappop(hq)
        
        nx = coor_x + dx[d]
        ny = coor_y + dy[d]
        
        # 가장 적은 거울 개수일 때의 다른 문에 도착 시
        if door[1] == (nx, ny):
            print(cnt)
            break
        
        if nx < 0 or nx >= n or ny < 0 or ny >= n or home[nx][ny] == '*':
            continue
        
        # 다음 방문 칸의 방향의 거울 개수를 더 작게 가능한 경우
        if vis[nx][ny][d] > cnt:
            vis[nx][ny][d] = cnt
            heapq.heappush(hq, (cnt, (nx, ny), d))
            
        # 다음 방문 칸에 거울을 설치가 가능한 경우
        if home[nx][ny] == '!':
            ld, rd = (d + 3) % 4, (d + 1) % 4
            
            # 거울을 좌측 방향으로 했을 때
            if vis[nx][ny][ld] > cnt + 1:
                vis[nx][ny][ld] = cnt + 1
                heapq.heappush(hq, (cnt + 1, (nx, ny), ld))
                
            # 거울을 우측 방향으로 했을 때
            if vis[nx][ny][rd] > cnt + 1:
                vis[nx][ny][rd] = cnt + 1
                heapq.heappush(hq, (cnt + 1, (nx, ny), rd))
```
- 각 칸마다 4개의 방향으로 해당 칸의 방향에 따른 거울 개수를 기록할 `vis[][][]` 선언
- 문의 시작 위치인 `door[0]`에 거울 개수가 0인 상태로 4개의 방향을 큐에 넣음
- `cnt`, `coor_x`, `coor_y`, `d`은 각각 거울 개수, 행과 열, 방향을 나타냄
- `nx`, `ny`은 다음 조사할 칸을 나타냄
- 다음 칸이 집 내부이며, 벽이 아닌 경우 진행
- 해당 방향으로 다음 칸을 갈 때 거울의 개수가 더 작은 경우 `vis[][][]`에 저장한 후 큐에 넣음
- 해당 방향으로 다음 칸을 갈 때 거울을 설치할 수 있는 경우 방향을 좌측 또는 우측으로 꺾을 수 있음
- `ld`, `rd`는 좌측, 우측 방향으로 꺾을 때의 값을 나타냄
- 해당 꺾은 방향으로 거울의 개수가 더 작을 때 값을 갱신한 후, 큐에 넣음
- 위 과정들을 반복한 후에, 해당 칸이 다른쪽 문일 경우 해당 **거울의 개수**를 출력  
_우선순위 큐로 거울의 개수가 **오름차순**으로 됌으로써 다른쪽 문 위치에 가장 먼저 도착한 경우가 곧 **최소 거울 개수**를 나타냄_
</details>

### 후기
- **각 칸의 방향**에 대해서 도달할 수 있는 최소 거울 개수를 생각하는 PS가 어려웠음
- C++ 의 경우 _Priority Queue_ 를 자꾸 내림차순 정렬이라는 것을 까먹음