### 1238번: 파티

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1238)
2. **도움 블로그** : https://kangmin1012.tistory.com/8

**문제 조건**
- N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.
- X번 마을에 파티를 열어 N명의 학생들이 모이기로 했다. 이 마을 사이에는 M개의 단방향 도로가 있고, $T_i$의 시간을 소비
- 각 학생들은 파티에 참여를 하고 다시 마을로 돌아와야 하고, 학생들은 최단 시간으로 갔다 오기를 원한다.

**출력**  
- X번 마을에서 파티를 열었을 때 N명의 학생들 중 갔다 오는 소요 시간이 가장 오래걸리는 시간을 출력

### 풀이
1. 입력받은 `M`개의 도로를 `Dijkstra`로 `X`번 마을에서 출발하면은 `X`번 마을에서 각 마을 까지 도달하는 최단 시간을 알 수 있다.
2. 문제는, **각 마을에서 `X`번 마을까지 도착하는 최단 시간을 구하는 것**이다.
3. `M`개의 도로를 입력받을 때, 시작 위치와 도착 위치를 반대로 저장하는 변수에 `Dijkstra`를 `X`번 마을에서 출발하면은 각 마을에서 `X`번 마을에 도착하는 최단 시간을 구할 수 있다.
4. `min_dis[0]` 배열에는 `X`번 마을에서 출발하는 최단 시간, `min_dis[1]` 배열에는 각 마을에서 `X`번 마을에 도착하는 최단 시간을 저장
5. `res[]`은 `min_dis[0]`과 `min_dis[1]` 값의 각 합을 저장
6. 1번 마을부터 n번 마을까지의 합 중에서 `max_element STL`을 이용하여 최댓값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void input() {
    cin >> n >> m >> x;
    for(int i = 0; i < m; i++) {
        int a, b, t;
        cin >> a >> b >> t;
        v[0][a].push_back({t, b});
        v[1][b].push_back({t, a});
    }
    fill_n(&min_dis[0][0], 2 *1001, INF);
}

void solve() {
    int res[1001] = { 0, };
    
    dijkstra(0);
    dijkstra(1);

    for(int i = 1; i <= n; i++) {
        res[i] = min_dis[0][i] + min_dis[1][i];
    }
    
    cout << *max_element(res + 1, res + n + 1) << '\n';
}
```
- `input()`에서 `v[0]`은 `M`개의 도로를 입력받아, `X`번 마을에서 `Dijkstra`를 실행하여 X -> 각 도시의 최단 도착 시간을 저장
- `v[1]`은 `M`개의 도로의 반대 방향으로 저장하여 `Dijkstra`를 실행하여 각 도시 -> X 도시의 최단 도착 시간을 저장
- `min_dis[][]`에 `INF` 값으로 초기화
- `dijkstra`를 각 실행하여 `min_dis[][]`에 최단 소요 시간들을 저장
- `res[]`에 각 도시에서 `X`까지의 소요시간, 다시 도시로 도착하는 소요시간의 합을 저장
- 1번 마을부터 n번 마을까지의 최댓값을 출력
</details>

### 후기
- 가장 먼저 푼 방식은 `M`개의 도로를 입력받고, 각 마을마다 `Dijkstra`를 돌려서 최단 소요시간들의 합을 구해서 최댓값을 구했다.
- 하지만 더 좋은 방법으론, 방향의 반대로 구하는 것을 저장하여 `Dijkstra`를 하면은 바로 각 마을에서 `X`마을까지의 최단 소요를 알 수 있는 나름의 요령(?)의 생각이 필요한 문제였다.