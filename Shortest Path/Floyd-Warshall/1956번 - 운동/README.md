### 1956번: 운동

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1956)
2. **도움 블로그** : 

**문제 조건**
- V개의 마을과 E개의 도로로 구성되어 있는 도시
- 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로
- 도로를 따라 운동을 하기 위한 경로를 찾고자 하며, 운동을 한 후에는 다시 시작점 도시로 돌아와야 하므로 마을의 사이클을 찾기를 원함
- 하지만, 운동을 귀찮아하므로, **다시 처음 마을로 돌아오는 사이클을 이루는 도로의 길이의 합**이 최소가 되길 원함

**출력**  
- **최소 사이클의 도로 길이 합**을 출력하고, 만일 운동 경로를 찾을 수 없는 경우는 -1을 출력

### 풀이
1. _Floyd-Warshall_ 알고리즘으로 각 마을에서 최종적으로 도착할 수 있는 마을의 최소 길이의 합을 구함
2. 시작마을과 도착마을이 같을 때의 도로 길이 합으로 최소값들을 비교
3. 만일, 최소로 구한 값이 `INF`값인 경우는 출발하여 다시 출발 도시로 도착할 수 없는 것이므로 -1을 출력
4. `INF` 값이 아닌 경우면은 해당 값을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    for(int k = 1; k <= v; k++) {
        for(int i = 1; i <= v; i++) {
            for(int j = 1; j <= v; j++) {
                if(dist[i][k] && dist[k][j]) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
    
    int ans = INF;
    for(int i = 1; i <= v; i++) {
        ans = min(ans, dist[i][i]);
    }
    
    cout << (ans != INF ? ans : -1) << '\n';
}
```
- _Floyd-Warshall_ 를 통해 각 도시에서 도착 도시까지의 최소 길이의 합을 구함
- `ans` 값에 `INF` 값을 저장한 후에, `dist[][]` 값에 시작과 도착값이 같은 경우의 최소 길이들을 `ans` 값과 비교
- `ans` 값이 `INF`인 경우는 모든 도시들이 다시 출발 도시로 도착할 수 없는 경우이므로 -1을 출력
- `ans` 값이 `INF`가 아닌 경우는 출발하여 도착 도시가 출발 지점과 같을 수 있는 경우가 존재한 것이므로 이때 최소 값을 출력
</details>

### 후기
- 