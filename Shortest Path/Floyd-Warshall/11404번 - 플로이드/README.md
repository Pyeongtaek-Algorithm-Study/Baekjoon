### 11404번: 플로이드

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/11404)
2. **도움 블로그** : 

**문제 조건**
- `n`개의 도시가 있으며, 한 도시에서 출발하여 다른 도시에 도착하는 `m`개의 버스가 존재
- 각 버스를 탈 때 필요한 비용이 있다.

※ 한 도시에서 출발하여 다른 도시로 도착하는 **같은 노선인 버스가 여러개 일 수 있다.**

**출력**  
- 모든 도시의 쌍에 대하여 도시 `A`에서 `B`로 가는 필요한 비용의 최솟값을 구하기

### 풀이
1. **모든 지점에 대하여 최단 경로를 구하는 알고리즘 문제이므로 플로이드-워셜 알고리즘 문제**  
  ※ 플로이드-워셜 : 한 지점에서 다른 지점까지 가는 경로에서 중간 사이마다 경로들도 최단 경로들이다. 시간복잡도 $O(n^3)$

2. 도시가 자기자신인 경우는 거리가 0이고, 그 외는 큰 값(`MAX`)으로 설정
3. `M`개의 버스 노선을 입력받을 때, `cost`를 비교하며 더 작은 비용이 드는 것을 저장
4. `k`, `i`, `j`의 변수를 선언하고 `k`는 중간을 거쳐갈 도시, `i`는 출발할 도시, `j`는 도착할 도시를 의미
5. 3중 반복문을 하며 가장 첫번째는 중간을 거쳐갈 도시인 `k`를 설정하고 `i`, `j`는 순차적으로 반복문으로 설정
6. 모든 경로를 돌면서, `i` -> `j` 가는 것과 `i` -> `k` -> `j`로 가는 경로의 비용을 비교하여 저장
7. 전체를 다돌고 나면은 출력할 때 해당 경로가 여전히 `MAX`인 경우는 0으로 변경하여 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void input() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            if(i == j) map[i][j] = 0;
            else map[i][j] = MAX;
        }
    }
    int st, end, cost;
    while(m--) {
        cin >> st >> end >> cost;
        map[st][end] = min(map[st][end], cost);
    }
}

void solve() {
    for(int k = 1; k <= n; k++) {
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
            }
        }
    }

    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            if(map[i][j] == MAX) cout << 0 << " ";
            else cout << map[i][j] << " ";
        }
        cout << "\n";
    }
}
```
- `i` -> `j`로 가는 경로에 대해 매우 큰 비용인 `MAX`값을 할당하고, 자기 자신 도시는 0으로 설정
- `i` -> `j`로 가는 버스의 노선이 여러개일 수 있으므로, 버스 노선을 저장할 때 `cost`를 비교하여 저장
- 플로이드-워셜 알고리즘으로 `i` -> `j`로 갈 때의 값과 중간 k 도시를 거쳐서 가는 것과 비교하여 최소값을 저장
- 결과를 출력할 때 값이 여전히 `MAX`인 비용인 노선은 0으로 출력하여 그외는 해당 최소 비용을 출력
</details>

### 후기
- 플로이드-워셜 알고리즘은 간단한 구성이지만, 3중 반복문을 사용하기 때문에 약 500개 이상의 도시일 경우는 힘들다.