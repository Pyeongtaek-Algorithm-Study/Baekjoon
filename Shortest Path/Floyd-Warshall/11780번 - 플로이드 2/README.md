### 11780번: 플로이드 2

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/11780)
2. **도움 블로그** : 

**문제 조건**
- N 개의 도시가 있음. 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 존재
- 각 버스는 한 번 사용할 때 필요한 비용이 있음
- 모든 도시의 쌍$(A, B)$에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하기

**출력**  
- N개의 줄을 통해 i -> j 도시로 가는 최소 비용을 공백을 두고 출력하며 갈 수 없는 경우는 0으로 대체
- 다음에 N X N 개의 줄에는 각 i -> j 도시로 가는 최소 비용에 포함되어 있는 도시의 개수를 출력 후, 각 경로를 공백을 두고 출력
- 각 경로를 출력할 때에 i와 j 도시도 출력해야 하며, 갈 수 없는 경우에는 0으로 대체

### 풀이
1. 전형적인 _Floyd-Warshall_ 문제로, 마찬가지로 임의의 `k` 도시를 거쳐서 갈 수 있으며 이 떄의 최소 비용일 때 값을 갱신
2. 새롭게 값을 갱신할 때에는 경로가 변경되는 것이므로, 기존의 `i` -> `j` 로 가는 도시의 경로를 제거
3. `i` -> `k` -> `j` 로 가는 경로이므로 `i` -> `k` 로 가는 경로를 저장함. 이때 마지막인 `k` 도시까지가 아닌 `k` 도착 **전 도시까지만 경로**에 추가
4. 다음 경로인 `k` -> `j` 로 가는 경로를 저장. 이때는 `k` 도시부터 마지막인 `j` 도시까지의 경로를 저장
5. 이렇게 하면 `k` 도시가 **중복**으로 들어가지 않고, 정확하게 `i` -> `j`를 가는 경로에서 `k`를 거쳐서 가는 경로를 만들 수 있음
6. 위 과정을 반복하여 최종적인 각 경로들을 저장한 후에 값들을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    for(int k = 1; k <= n; k++) {
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                if(i == j) continue;
                if((bus[i][k] && bus[k][j]) && (bus[i][j] > bus[i][k] + bus[k][j])) {
                    bus[i][j] = bus[i][k] + bus[k][j];
                    
                    path[i][j].clear();
                    path[i][j].insert(path[i][j].end(), path[i][k].begin(), path[i][k].end() - 1);
                    path[i][j].insert(path[i][j].end(), path[k][j].begin(), path[k][j].end());
                }
            }
        }
    }
    
    print_ans();
}
```
- 임의 도시 `k`를 거쳐서 갈 수 있는 `i` -> `k` -> `j` 경로를 선택
- `i` -> `k` 경로가 있으며 `k` -> `j`로 가는 경로도 존재하면서 기존 경로 비용보다 더 작은 값일 경우 조건문을 실행
- 기존 비용을 `k`를 거쳐서 가는 값으로 최소 비용을 갱신
- 기존 경로인 `path[i][j]`의 경로를 제거
- 경로를 다시 설정할 때 `i` -> `k` 로 가는 경로에서 **`k` 도시를 제외한 나머지 경로**들을 추가
- 아까 추가한 경로에서 `k` -> `j` 로 가는 경로를 추가(`k` 도시의 **중복을 제거**하기 위해 위 과정에서 `k`를 제외한 경로만 추가)
- `bus[][]` 에는 최소 비용 값이 저장되어 있고, `path[][]` 에는 최소 비용으로 가는 경로가 저장되어있으므로 출력 조건에 맞도록 출력
</details>

### 후기
- 처음에는, 기존 알고리즘의 코드 패턴으로 알고 있어서 PS 떠올리기가 어려웠지만, 최소 비용이 갱신되는 과정을 생각해보니 경로도 설정하는 방법을 도출할 수 있었음