### 17435번: 합성함수와 쿼리

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/17435)
2. **도움 블로그** : 
    - https://tech-interview.tistory.com/175
    - https://ghqls0210.tistory.com/145

**문제 조건**
- 함수 $f : \{1, 2, ..., m\} → \{1, 2, ..., m\}$라 할 때, $f_n : \{1, 2, ..., m\} → \{1, 2, ..., m\}$라고 정의
    - $f_{1}(x) = f(x)$
    - $f_{n+1}(x) = f(f_n(x))$
- Ex. $f_{4}(1) = f(f(f(f(1))))$

**출력**  
- 주어지는 n, x 마다 $f_n(x)$를 계산하는 쿼리 결과를 출력

### 풀이
1. $f(1), ..., f(m)$에서 m은 200,000 이하이고, 쿼리도 200,000이하, 또한 n은 500,000 이하이므로 단순하게 한단계씩 재귀적으로 값을 찾으면 **시간초과** 발생
2. 따라서, 중간중간 합성함수를 한 단계식이 아닌 **한 번에 이동하는 아이디어**가 필요
3. 한 번에 이동할 때의 기준을 **2의 로그 스케일**로 계산  
_Ex. 15 = 1 + 2 + 4 + 8로 나타낼 수 있으므로 4번의 과정으로 값을 알아낼 수 있음_
4. 따라서, 임의의 값에서 **$2^k$ 이동한 위치**들을 각각 2차원 배열에 저장
5. `n`, `x`값을 입력받았을 때, f(x)의 값에서 `n`을 2 로그 스케일의 합산 과정으로 차례대로 올라가면은 해당 `n`번째의 **합성함수 값**을 알 수 있음

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void sparse_table(int n) {
    for(int j = 1; j < 20; j++) {
        for(int i = 1; i <= m; i++) {
            // 정점 i에서 2^j번 이동한 후의 정점
            num[i][j] = num[num[i][j-1]][j-1]; 
        }
    }
}
```
- f(`i`) 가 2^`j` 이동 한 후의 값을 `num[][]`에 저장

```cpp
void solve() {
    sparse_table(20);
    cin >> q;
    
    for(int i = 0, n, x; i < q; i++) {
        cin >> n >> x;
        for(int i = 0; 0 < n; i++) {
            if(n & 1) x = num[x][i];
            n >>= 1;
        }
        cout << x << '\n';
    }
}
```
- `sparse_table()`로 2^20까지의 합성 함수 값을 `num[][]`에 저장
- 입력받은 `n`을 이진수로 했을 때 해당 `i`번째 비트가 있을 때, 해당 `f_i(x)`을 `x` 값에 저장
- `n`을 _Bitshift_ 를 하면서 2로 나눈 값으로 줄이고 `n`이 0이 아닐 때까지 위 과정을 반복
- 최종적으로 구한 `x`값을 출력
</details>

### 후기
- 시간복잡도를 O(n)에서 O(log(n))으로 줄일 수 있었음