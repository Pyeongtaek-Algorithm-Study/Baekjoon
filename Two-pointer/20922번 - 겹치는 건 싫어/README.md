### 20922번: 겹치는 건 싫어

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/20922)
2. **도움 블로그** : 

**문제 조건**
- 홍대병에 걸린 도현이는 겹치는 것을 매우 싫어함.
- 수열에서 같은 원소가 여러 개 들어 있는 수열을 싫어함.

**출력**  
- 길이가 N인 수열로, 같은 정수가 K개 이하로 하는 **최장 연속 부분 수열의 길이**를 출력

### 풀이
1. 연속 부분 수열을 만들기 위해 두 개의 포인터를 가짐
2. 두 포인터(시작 포인터, 끝 포인터) 둘다 처음 시작하는 위치에 존재
3. 끝 포인터는 연속 부분 수열의 끝 부분으로 1칸씩 증가시켜 해당 위치의 숫자의 개수들을 기록
4. 만일 끝 포인터의 숫자의 개수가 K개를 넘겼을 때, **시작 포인터를 1칸씩 증가시키고, 해당 숫자의 개수를 1개 감소시킴**
5. 끝 포인터를 움직일 땐 수열의 길이를 **증가**시키고, 시작 포인터가 움직일 시에는 수열의 길이를 **감소**시킴
6. 위 과정을 끝 포인터가 N개의 수열의 마지막 원소에 도착할 때까지 반복
7. 최종적으로 구한 수열의 길이가 곧 문제에서 제시한 조건에 맞는 **최장 연속 부분 수열의 길이**를 나타냄

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int len = 0, ans = 0;
    
    for(int i = 0, j = 0; i < n; i++) {
        int cur = arr[i];
        cnt[cur]++;
        len++;
        
        while(cnt[cur] > k) {
            cnt[arr[j++]]--;
            len--;
        }
        
        ans = max(ans, len);
    }
    
    cout << ans << '\n';
}
```
- 부분 수열들의 길이를 나타낼 `len`과 저장된 `len`값들 중에서 가장 큰 값을 나타낼 `ans`
- `i`는 끝 포인터를, `j`는 시작 포인터로 둘다 시작은 처음 위치에 존재
- 현재 `i`번째 위치한 숫자를 `cur`에 저장 후, 해당 숫자의 개수를 1증가시킴
- 부분 수열에서 `i`번째 위치한 숫자를 포함된 것이므로 `len`도 1증가시킴
- 만일, 해당 숫자의 개수가 `k`를 넘어섰을 경우, 시작 포인터인 `j`를 증가시켜서 `j`번째에 위치한 숫자 개수들과 `len`을 1씩 감소시킴
- 위 과정에서 얻은 `len` 길이와 `ans` 값을 비교해서 더 큰 값을 `ans`값에 저장
- 최종적으로 구한 `ans` 값에는 최장 연속 부분 수열의 길이가 저장된 것이므로 이를 출력
</details>

### 후기
- python의 defaultdict()에 대해서 처음 써봄 dict에서 기본 설정 초기화 값을 설정해주는 함수