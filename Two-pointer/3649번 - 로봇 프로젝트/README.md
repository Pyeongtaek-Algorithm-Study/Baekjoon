### 3649번: 로봇 프로젝트

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/3649)
2. **도움 블로그** : 

**문제 조건**
- 로봇을 만들던 중에 구멍을 막을 두 레고 조각이 필요
- 구멍의 너비는 x센티미터이고, 구멍에 넣을 두 조각의 길이의 합은 구멍의 너비와 정확하게 일치해야 함
- 구멍은 항상 두 조각으로 완벽하게 막아야 함

**출력**  
- 각 테스트 케이스마다, 구멍을 완벽하게 막을 수 있는 두 조각이 있으면 'yes $l_1$ $l_2$'을 출력하고 없는 경우는 'danger'를 출력
- 정답이 여러 개인 경우에는 두 레고의 차이가 큰 것으로 출력

### 풀이
1. 입력받은 레고의 크기를 오름차순으로 정렬
2. 왼쪽과 오른쪽 위치를 가리키는 각각의 포인터를 설정
3. 왼쪽 포인터와 오른쪽 포인터가 가리키는 레고의 크기를 더함
4. 더한 값이 더 크면은 오른쪽 포인터를 왼쪽으로 이동
5. 더한 값이 작으면은 왼쪽 포인터를 오른쪽으로 이동
6. 위 과정을 반복하여 정확한 크기만큼을 찾아서 반복
7. 가장 처음에 찾은 결과가 가장 서로 차이가 나는 레고 크기이므로 이때의 크기들을 출력
8. 만일, 위 과정을 찾을 때, 합해서 해당 크기가 없다면은 "danger"를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int st = 0;
    int en = lego.size() - 1;
    t *= 10000000;
    while(st < en) {
        if(lego[st] + lego[en] == t) {
            break;
        }
        else if(lego[st] + lego[en] > t) en--;
        else st++;
    }
    if(st < en) cout << "yes " << lego[st] << ' '<< lego[en] << '\n';
    else cout << "danger" << '\n';
}
```
- `t`값은 센티미터를 입력받으므로, 나노미터로 변환
- 왼쪽인 `st`, 오른쪽 `en`를 가리키는 포인터 선언
- 레고들에서 각각의 위치에 있는 2개의 레고의 크기를 더함
- 더해서 찾고자 하는 값보다 더 큰 것인지 혹은 작은지를 **비교**해서 왼쪽, 오른쪽 포인터들을 이동시킴
- 위 과정을 반복해서 정확한 값이 있으면 해당 `st`, `end`값에 있는 레고크기를 출력
- 만일, 없으면은 _"danger"_ 를 출력
</details>

### 후기
- 테스트 케이스가 딱히 언급이 없었는데, 입력값이 있으면 무한으로 할 수 있는 코드가 있다는게 신기했음
