### 1806번: 부분합

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/1806)
2. **도움 블로그** : 

**문제 조건**
- 길이가 N인 수열
- 수열에서 연속된 수들의 부분합 중 그 합이 S 이상이 되는 것

**출력**  
- 합이 S 이상인 부분합의 최소 길이를 출력

### 풀이
1. 배열에서 투 포인터를 활용하여 임의의 부분수열을 가리키도록 함
2. 부분수열의 합을 나타낼 `sum`과 입력받은 `s`값을 비교
3. `sum`값이 `s`값보다 낮으면은 오른쪽 포인터인 `end`값을 증가 후 `sum`에 추가
4. `sum`값이 `s`값보다 크면은 왼쪽 포인터를 증가시킨 후 이전 값을 빼기
5. 위 과정을 반복하다가 해당 부분수열의 합이 s보다 클 떄의 길이의 최소를 비교
6. 이후 부분합의 최소 길이를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int st = 0, end = 0;
    int sum = seq[0];
    int ans = 1e9;
    
    while(st <= end && end < n) {
        if(sum < s) {
            end++;
            sum += seq[end];
        }
        else {
            ans = min(ans, end - st + 1);
            sum -= seq[st];
            st++;
        }
    }
    
    cout << (ans != 1e9 ? ans : 0) << '\n';
}
```
- 부분 수열의 시작과 끝을 나타낼 `st`, `end` 와 부분 수열의 합인 `sum`
- `end` 값이 시작점과 동일하게 시작하여 `sum`은 시작값과 동일
- 이후에 `s`와 `sum`값을 비교하여 `sum`값이 크면은 `st`값을 앞으로 움직여서 부분 수열을 줄이도록 함.
- 반대인 경우는 `end`값을 증가시켜서 부분 수열을 증가시킴
- `sum`이 `s`값보다 크거나 같으면은 해당 부분수열의 길이를 비교하여 최소 길이를 갱신
- 이후 다 확인 한 후에, `ans`값을 기존 큰수(1e9)와 비교하여 길이 또는 불가능인 0값을 출력
</details>

### 후기
- 누적합을 이용하는 것인줄 알았지만 이중 반복문으로 시간초과가 발생되었음
- 0이 출력되는 경우도 있어서 빼먹으면 안됐음