### 1107번: 리모콘

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1107)

**문제 조건**
- 숫자 0~9와 +, -의 버튼이 리모콘에 존재. +는 현재 채널에서 +1된 채널로 이동하고, -는 현재 채널에서 -1된 채널로 이동  
(0채널에서 -를 눌러도 변하진 않는다.)
- 고장난 버튼 개수 M과 고장난 숫자 버튼을 입력받고, 고장난 버튼은 채널에 입력할 수 없음

**출력**  
- 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지 출력 

### 풀이
> **최소로 가는 방법 : 가고자하는 채널과 가장 인접하고, 고장난 버튼이 없는 채널에서 +, -로 이동하는 것**
1. 기본 시작 채널은 100번이므로 `abs(N-100)`의 값을 저장  
_채널이 100번 보다 작을 경우가 있을 수 있으므로 절대값함수를 이용_
2. 채널의 최대값은 **500000**이지만, 입력받을 수 있는 채널은 넉넉히 잡아 **1000000**까지 조사
3. `bool broke[10] = {0, }`을 생성하고 부서진 리모콘 숫자 버튼을 해당 위치에 저장  
ex. 1, 4, 6 버튼 고장 -> {0, 1, 0, 0, 1, 0, 1, 0, 0, 0} 로 저장
4. `check()` 함수를 생성하여 가고자 하는 채널을 문자열로 변환하여 각 자리마다 부서진 숫자 버튼이 있는지 확인
5. 이동 가능한 채널이면, 버튼 횟수는 `abs(N - 가능 채널) + 채널 길이` 
6. 기존 최소 횟수와 비교하며 1000000까지 채널 조사 


### 핵심 코드

```
bool check(int i, bool broke[]) {
    string ss = to_string(i);
    for(int i = 0; i < ss.length(); i++) {
        if(broke[ss[i] - '0']) return false;
    }
    return true;
}
// ---- 구분선 ----
while(i < 1000001) {
    if(check(i, broke)) {
        tmp = abs(N - i) + to_string(i).length();
        m = min(m, tmp);
    }
    i++;
}
```
- check 함수
    - 채널을 문자열로 변환한 후, 각 자리마다 부서진 채널의 버튼이 있는지 확인
    - 부서진 버튼이 없는 채널이면 `true`, 있는 채널이면 `false` 

- while문
    - 1000000까지 채널을 조사하여, 이동 가능 채널이면 이동 횟수 구하기 `abs(N - i) + to_string(i).length()`
    - 최소 횟수 비교

