### 4991번: 로봇 청소기

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/4991)
2. **도움 블로그** : 
    - https://codingnotes.tistory.com/120
    - https://chldkato.tistory.com/66

**문제 조건**
- 직사각형 모양의 방을 로봇 청소기를 이용해 청소하고, 로봇 청소기는 유저가 직접 경로 설정 가능
- 방의 크기는 1 x 1인 정사각형 칸으로 나뉘어져 있으며, 로봇 청소기도 같은 크기
- 방의 각 칸은 깨끗한 칸과 더러운 칸으로 나뉘고, 로봇 청소기는 더러운 칸을 방문해서 깨끗한 칸으로 바꿈
- 일부 칸에는 가구가 놓아져 있고, 크기는 1 x 1이며, 로봇 청소기는 가구가 놓여진 칸은 이동할 수 없음
- 로봇은 한 번 움직일 때 인접한 상하좌우 칸 이동이 가능하며 **로봇은 같은 칸을 여러 번 방문** 할 수 있음

**출력**  
- 각 테스트 케이스마다 더러운 칸을 모두 깨끗한 칸으로 바꾸는 **로봇 청소기의 최소 이동 횟수**를 출력
- 만약, **방문할 수 없는** 더러운 칸이 존재 시에 -1 을 출력

### 풀이
1. 로봇 청소기와 먼지의 위치가 주어졌을 때 이때 **로봇 청소기가 먼지를 치울 수 있는 순서인 경우의 수**가 다량으로 존재
2. 각각의 먼지 위치를 _vector_ 에 담아서 순열로 경우의 수를 확인
3. 모든 경우의 수를 따지면서 먼지를 순차적으로 로봇 청소기가 청소하면서 이동한 횟수들을 비교하여 최솟값을 찾음
4. `m[][][][]` 을 통해서 기존 시작위치(x, y)와 도착위치(x, y)의 거리를 _BFS_ 로 조사하여 저장하며 이미 값이 있을 경우에는 **이 값을 활용하여 시간을 단축**
5. 로봇 청소기가 다음 먼지로 도달할 수 없는 경우에는 -1 값을 출력하여 다음 테스트 케이스로 넘어감
6. 먼지를 청소하는 순서들의 경우의 수를 모두 확인하여 `ans` 값이 초기에 설정해둔 매우 큰 값이 아닌 경우는 **최소 이동 횟수를 구한 것**이므로 이를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void solve() {
    int ans = BIG_NUM;
    int m[MAX][MAX][MAX][MAX] = { 0, };

    do {
        pair<int, int> tr = robot;
        char tmp[MAX][MAX];

        for(int i = 0; i < h; i++) {
            for(int j = 0; j < w; j++) {
                tmp[i][j] = board[i][j];
            }
        }
        
        int move = 0;
        for(int i = 0; i < dust.size(); i++) {
            tmp[dust[i].X][dust[i].Y] = 'o';
            tmp[tr.X][tr.Y] = '.';
            
            if(m[tr.X][tr.Y][dust[i].X][dust[i].Y] == 0) {
                int dist = bfs(tmp, tr, dust[i]);
                m[tr.X][tr.Y][dust[i].X][dust[i].Y] = dist;

                if(dist == -1) {
                    move = BIG_NUM;
                    break;
                }
                
                move += dist;
            }
            else {
                if(m[tr.X][tr.Y][dust[i].X][dust[i].Y] == -1) {
                    move = BIG_NUM;
                    break;
                }
                
                move += m[tr.X][tr.Y][dust[i].X][dust[i].Y];
            }         
            tr = dust[i];
        }
        
        ans = min(ans, move);
    } while(next_permutation(dust.begin(), dust.end()));

    cout << (ans == BIG_NUM ? -1 : ans) << '\n';
}
```
- `ans`는 초기 매우 큰 값과, `m[][][][]` 은 시작위치(x, y)에서 도착위치(x, y)까지의 거리를 적어 놓는 배열
- 로봇의 가장 처음 시작 위치를 `tr`과 `tmp[][]` 값에 초기 `board[][]` 값을 저장
- `dust`에 저장된 먼지의 위치의 순서대로 방문하며 현재 로봇위치를 깨끗한 칸으로, 먼지가 있는 위치를 로봇으로 변경
- 만일 방문할 먼지 칸에 `m[][][][]`에 저장된 값이 없다면 _BFS_ 로 확인하여 로봇에서 먼지칸까지 거리를 확인
- 도달할 수 있는 거리라면 값을 저장하고, 도달할 수 없는 칸이라면은 `move` 값을 `BIG_NUM`으로 하여 반복문을 종료시켜 -1 값을 출력
- 만일 해당 위치의 거리 값이 `m[][][][]`에 있으며 -1 값이 아니면은 도달할 수 있는 것이므로 `move` 값에 합산
- 로봇의 위치를 해당 먼지 위치로 저장하여 모든 먼지를 치울 때까지 반복
- 최종적으로 로봇 청소기가 돌면서 먼지를 순차적으로 깨끗하게 한 이동 횟수인 `move`와 최소 이동거리인 `ans`와 비교하여 더 최솟값을 갱신
- dust에 저장된 먼지들을 순열로 조합하여 먼지를 돌면서 순회할 순서의 경우의 수를 다 확인하도록 함
- 최종적으로 `ans`에 저장된 값이 `BIG_NUM`이 아니면은 모든 먼지를 치울 수 있는 것이므로 값을 출력
</details>

### 후기
- 자꾸 입력할 때 초기화하지 않아 solve() 를 실행해도 틀린 값이 나왔다, 여러 케이스 입력값에는 항상 변수들을 초기화하는 것을 염두해야 겠다.