### 2589번: 보물섬

1. **문제 사이트** : [바로가기](https://www.acmicpc.net/problem/2589)
2. **도움 블로그** : 

**문제 조건**
- 보물섬 지도는 직사각형 모양이며 여러 칸으로 나뉘어짐
- 각 칸은 육지(L)이나 바다(W)로 표시하며, 이동은 상하좌우로 이웃한 육지로만 가능하고 한 칸 이동하는데 한 시간 소요
- 보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 **두 곳**에 나뉘어 묻혀있음
- 육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두번 이상지나거나, 멀리 돌아가서는 안됨


**출력**  
- 보물 지도가 주어질 때, 보물이 묻혀 있는 **두 곳 간의 최단 거리로 이동하는 시간**을 출력

### 풀이
1. 각 칸을 살펴보며 육지일 경우 _BFS_ 알고리즘을 통해 가장 멀리 있는 칸의 길이를 체크
2. 체크한 길이가 출력할 값과 비교하여 더 큰 값일 경우 값을 갱신
3. 위 과정을 모든 육지마다 반복하여 최종적으로 구한 **보물의 거리 값**을 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```cpp
void bfs(int x, int y) {
    int vis[LIM][LIM] = { 0, };
    queue<pair<int, int> > Q;
    Q.push({x, y});
    vis[x][y] = 1;
    
    while(!Q.empty()) {
        pair<int, int> cur = Q.front(); Q.pop();
        ans = max(ans, vis[cur.X][cur.Y] - 1);
        
        for(int i = 0; i < 4; i++) {
            int nx = cur.X + dx[i];    
            int ny = cur.Y + dy[i];
            
            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            if(vis[nx][ny] || map[nx][ny] == 'W') continue;
            
            vis[nx][ny] = vis[cur.X][cur.Y] + 1;
            Q.push({nx, ny});
        }
    }
}
```
- 일반적인 _BFS_ 알고리즘으로 자세한 설명은 생략
</details>

### 후기
- 두 노드의 최장 거리로 생각하여 풀면은 틀림. 틀리는 엣지 케이스가 있기에 모든 육지일 때 비교하여 봐야 함.
- 두 노드의 최장 거리 : 임의의 한 노드에서 가장 먼 노드를 찾고, 찾은 노드에서 다시 가장 먼 노드가 해당 최장 거리