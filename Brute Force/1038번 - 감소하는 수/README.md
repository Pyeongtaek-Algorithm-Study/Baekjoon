### 1038번: 감소하는 수

문제 사이트 : [바로가기](https://www.acmicpc.net/problem/1038)

**문제 조건**
- 음이 아닌 정수 X의 가장 큰 자릿 수부터 작은 자릿수까지 감소한다면, 그 수를 **감소하는 수**  
_ex. 321, 950은 감소하는 수, 322와 958은 아님_
- 0은 0번째, .., 10은 10번째이다. 만약 N번째 감소하는 수가 없다면 -1 출력 _( 9876543210 부터는 존재X )_

**출력**  
- **N**번째로 감소하는 수를 출력

### 풀이
1. 단순하게 `Bruteforce`로 자릿수를 비교하면서 하면 시간 초과 **(다른 풀이 필요)**  
재귀적으로 찾는다면 메모리 초과
2. 가장 큰 감소하는 수는 987...210이므로 `int`형이 아닌 `long long` 타입으로 선언 필요
3. 어떤 수에 대해서 현재 자릿수가 앞선 자릿수보다 작아야 하므로 `queue`를 활용
4. **1~9**까지의 숫자를 `queue`에 넣음.
5. `idx`를 10으로 선언해서 `idx`가 `N`이하와 `queue`가 비지 않았을 때까지 반복
6. `queue`에서 처음값을 출력하고 **10**을 나눠 해당 수보다 작은 수들을 다시 `queue`에 넣으며, `dp`에도 해당 번째에 값을 저장
7. `while`반복문이 종료되고, `N`번째 값이 **존재하면 출력**, `0`이라면 해당 번째 감소하는 수가 `9876543210` 내에 존재하지 않으므로 **-1**를 출력

### 핵심 코드

<details>
<summary>코드 보기</summary>

```
void bruteforce() {
    queue<long long> q;
    
    for(int i = 1; i <= 9; i++) {
        q.push(i);
        dp[i] = i;
    }
    
    if(0 <= n && n <= 10) {
        cout << n << endl;
    }
    
    int idx = 10;
    while(idx <= n && !q.empty()) {
        long long num = q.front();
        q.pop();
        
        int last = num % 10;
        for(int i = 0; i < last; i++) {
            q.push(num * 10 + i);
            dp[idx++] = num * 10 + i;
        }
    }
    
    if(dp[n]) cout << dp[n] << endl;
    else cout << -1 << endl;
}
```
- 1~9를 `queue`에 삽입
- N이 10이하일 경우 해당 수를 그대로 출력 **(0~10까지는 감소하는 수)**
- `idx = 10` 을 선언하고 `idx`가 `n`번째에 도달할 때까지 감소하는 수를 구하기
- `queue`의 처음 값을 기준으로 **10을 나눈 나머지 값의 last에 저장**
- `for`반복문으로 `num`값에 해당 `queue` 값을 저장해 10을 나눠 **해당 수보다 작을 때까지의 N번째를 dp에 저장**
- `while`반복문으로 `idx`가 최종적으로 구할려는 `n`을 초과하거나, `n`까지 도달하기 전에 `queue`가 비어있으면 반복문이 종료
- `dp[n]`에 값이 0이 아니면은 값이 저장이 된 것이므로 출력하고, 0 _(해당 n번째의 감소하는 수는 존재 X)_ 은 -1을 출력

</details>